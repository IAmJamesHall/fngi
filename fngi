#!/usr/bin/python3
"""
See ./harness.md for full documentation.
"""

import signal
import threading
import select
import re
import os
import collections
import sys
import enum
import pprint
import time
from typing import Dict, Tuple, List, Deque
from dataclasses import dataclass
import subprocess
import argparse

DONE = False
def sigint(signal, frame):
  global DONE
  DONE = True

signal.signal(signal.SIGINT, sigint)

parser = argparse.ArgumentParser(description='Fngi linux harness.')
parser.add_argument('--compile', action='store_true', help="Recompile spore binary")
parser.add_argument('--test', action='store_true', help="Run tests")
parser.add_argument('--valgrind', action='store_true', help="Run with valgrind")
parser.add_argument('--log', default='LOG_USER', help="The log level, i.e. LOG_INFO.")
parser.add_argument('--syslog', default='LOG_COMPILER', help="The log level, i.e. LOG_INFO.")

import zoa
from zoa import readexact


SZ_MASK   = 0x30
NOSZ_MASK = 0xCF

SZ1 = 0x00
SZ2 = 0x10
SZ4 = 0x20
SZA = 0x20

META_TY_MASK = 0xE0 # Upper three bits determine type
TY_LOCAL     = 0x40 # local variable, has varMeta. Accessed with FTLL/SRLL
TY_FN        = 0x20 # function, can be called and has an fnMeta
TY_LOCAL     = 0x40 # local variable, has varMeta. Accessed with FTLL/SRLL
TY_GLOBAL    = 0x60 # global variable, has varMeta. Accessed with FTGL/SRGL

ZOAB_LOG = 0x03

ERRORS = []

class CheckDoneReader:
  """A reader that can be killed."""
  def __init__(self, fd):
    self.fd = fd

  def read(self, n, orNewline=False):
    out = bytearray()
    while n:
      (rdRdy, wrRdy, xRdy) = select.select([self.fd.fileno()], [], [], 0.2)
      assert not wrRdy
      assert not xRdy
      if rdRdy:
        b = os.read(self.fd.fileno(), n)
        if not b: break  # EOF
        out.extend(b)
        n -= len(b)
      elif DONE:
        # Read from bytestream until there is nothing, then respect DONE
        break # DONE looks like EOF
      if orNewline and b'\n' in out: break
    return out

def wantStr(b):
  try: return b.decode('utf-8')
  except ValueError: return b

def nice(value):
  if isinstance(value, bytes):
    return wantStr(value)
  if isinstance(value, int):
    return f"0x{value:X}"

def toRef(metaRef): return 0xFFFFFF & metaRef
def isTyLocal(meta):  return TY_LOCAL == (META_TY_MASK & meta)
def isTyFn(meta):     return TY_FN == (META_TY_MASK & meta)
def isTyGlobal(meta): return TY_GLOBAL == (META_TY_MASK & meta)
def metaSzI(meta):
  assert isTyLocal(meta) or isTyGlobal(meta)
  return (0x3 & meta) << 4

def szIToBytes(szI):
  szI = SZ_MASK & szI
  if szI == SZ1: return 1
  if szI == SZ2: return 2
  if szI == SZ4: return 4
  raise ValueError(szI)

class Lvl(enum.Enum):
  SILENT    = 0x00
  SYS       = 0x40
  USER      = 0x20
  TRACE     = 0x1F
  DEBUG     = 0x0F
  INFO      = 0x07
  WARN      = 0x03
  CRIT      = 0x01

LOG_SYS = 0x40

LOG_DICT = 0x02
LOG_ERR  = 0x05
LOG_FILE = 0x06
LOG_JMP   = 0x08
LOG_OP    = 0x09
LOG_LIT   = 0x0A
LOG_RET_SUCCESS = 0x0B
LOG_MEM   = 0x0C

class InstrClass(enum.Enum):
  C_OP   = 0x00
  C_SLIT = 0x40
  C_JMP =  0x80
  C_MEM =  0xC0

FIELD_ERR_CODE = 0x01
FIELD_MSG = 0x02


def integerBE(data):
  if len(data) == 1:
    return data[0]
  if len(data) == 2:
    return (data[0] << 8) + data[1]
  if len(data) == 4:
    return (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]
  raise ValueError(data)

def integerLE(data, l=None):
  if l is None: l = len(data)
  if l == 1:
    return data[0]
  if l == 2:
    return data[0] + (data[1] << 8)
  if l == 4:
    return data[0] + (data[1] << 8) + (data[2] << 16) + (data[3] << 24)
  raise ValueError(data)


@dataclass
class FngiEnv:
  """A Map of the Fngi env from trace logs."""
  dicts: dict
  fnLookup: dict
  glbls: dict
  codes: dict
  uncaughtErr: "ErrEvent" = None
  file: str = None
  pos: int = None
  currentFn: "DictEvent" = None
  instrLookup: dict = None

class Event:
  pass

@dataclass
class BasicEvent(Event):
  lvl: Lvl
  payload: List

@dataclass
class DictEvent(Event):
  localOffsets: Dict[int, "DictEvent"]
  isConst: bool
  key: bytes
  value: int
  buf: int
  offset: int
  isConstant: bool
  inLocalDict: bool
  localOffsets: dict

  @classmethod
  def from_(cls, z, env):
    key = z[1]
    value = integerBE(z[2])
    buf = integerBE(z[3])

    localOffsets = {}
    existing = env.dicts.get(buf, {}).get(key)
    if existing and toRef(existing.value) == toRef(value):
      localOffsets = existing.localOffsets  # keep existing locals

    return cls(
      isConst=bool(z[0][1]), # after lvl
      key=key,
      value=value,
      buf=buf,
      offset=integerBE(z[4]),
      isConstant=bool(integerBE(z[5])),
      inLocalDict=bool(integerBE(z[6])),
      localOffsets=localOffsets,
    )

  def isFn(self): return not self.isConstant and isTyFn(self.meta())
  def isLocal(self): return not self.isConstant and isTyLocal(self.meta())
  def isGlobal(self): return not self.isConstant and isTyGlobal(self.meta())

  def meta(self):
    assert not self.isConstant
    return self.value >> 24

  def ref(self):
    assert self.isGlobal() or self.isFn()
    return toRef(self.value)

  def localOffset(self):
    assert self.isLocal()
    return 0xFF & self.value

  def __repr__(self):
    if self.isConstant:
      return f"DictConstant[{nice(self.value)}]"
    if self.isLocal():
      return f"DictLocal[{nice(self.localOffset())}]"

    return (f"DictFn[{nice(self.meta())} @{nice(self.ref())} "
          + f"numLocals={len(self.localOffsets)}]")

ERR_DATA_NONE  = 0x00
ERR_DATA_INT1  = 0x01
ERR_DATA_DATA1 = 0x02
ERR_DATA_INT2  = 0x03
ERR_DATA_DATA2 = 0x04

def errData(z):
  print(z)
  if not z: return z
  ty = ord(z[0])
  if ty == ERR_DATA_INT1: return (integerBE(z[1]),)
  if ty == ERR_DATA_INT2: return (integerBE(z[1]), integerBE(z[2]))
  return z[1:]

@dataclass
class WorkingStk:
  totalLen: int
  data: List[int]

  @classmethod
  def from_(cls, z):
    data = [integerLE(z[1][i:i+4]) for i in range(len(z[1]) // 4)]
    data.reverse()
    return cls(
      totalLen=integerBE(z[0]),
      data=data,
    )

  def __repr__(self):
    andMore = ''
    if len(self.data) < self.totalLen:
      andMore = f'{self.totalLen - len(self.data):>3}... '

    data = ' '.join(f'#{v:<8X}' for v in self.data)
    return f"{{{andMore}{data}}}"

@dataclass
class ErrEvent(Event):
  errCode: int
  errName: str
  isCaught: bool
  ep: int
  ws: WorkingStk
  lineNo: int
  data: list
  callStkLen: int
  callStk: bytes
  localsStk: bytes

  def __repr__(self):
    return f"ErrEvent(code={nice(self.errCode)} name={self.errName.split()[0]})"

  @classmethod
  def from_(cls, z, env):
    code = integerBE(z[1])
    isCaught = bool(integerBE(z[2]))
    callStk, localsStk = None, None
    if isCaught: callStkLen = integerBE(z[7])
    else:
      callStk, localsStk = z[7]
      callStkLen = len(callStk) // 4
    return cls(
      errCode=code,
      errName=env.codes.get(code, "Unknown Err"),
      isCaught=isCaught,
      ep=integerBE(z[3]),
      ws=WorkingStk.from_(z[4]),
      lineNo=integerBE(z[5]),
      data=errData(z[6]),
      callStkLen=callStkLen,
      callStk=callStk,
      localsStk=localsStk,
    )

@dataclass
class FileEvent(Event):
  file: str

  @classmethod
  def from_(cls, z):
    return cls(file=z[1])


class ExecutionEvent(Event):
  pass

def fmtXDepth(xDepth):
  return '+' * xDepth

@dataclass
class JmpEvent(ExecutionEvent):
  instr: int
  name: str
  fnName: str
  szBytes: int
  jloc: int
  ws: WorkingStk
  xDepth: int

  @classmethod
  def from_(cls, z, env):
    instr = integerBE(z[1])
    jloc = integerBE(z[2])
    return cls(
      instr=instr,
      name=env.instrLookup.get(NOSZ_MASK & instr),
      fnName=env.fnLookup.get(jloc),
      szBytes=szIToBytes(instr),
      jloc=jloc,
      ws=WorkingStk.from_(z[3]),
      xDepth=integerBE(z[4]),
    )

  def __repr__(self):
    return (
        f"{fmtXDepth(self.xDepth):<10} {str(self.ws):<42} {self.name:>4}"
        + f"[{self.fnName}@{nice(self.jloc):<10}]"
    )


@dataclass
class RetSuccessEvent(ExecutionEvent):
  instr: int
  name: str
  jloc: int
  ws: WorkingStk
  xDepth: int

  @classmethod
  def from_(cls, z, env):
    instr = integerBE(z[1])
    return cls(
      instr=instr,
      name=env.instrLookup.get(instr),
      jloc=integerBE(z[2]),
      ws=WorkingStk.from_(z[3]),
      xDepth=integerBE(z[4]),
    )

  def __repr__(self):
    return (
      f"{fmtXDepth(self.xDepth):<10} {str(self.ws):<42} {self.name:>4}"
      + f"[@{nice(self.jloc):<10}]"
    )

RETZ = 0x01
RET  = 0x02
XL   = 0x84,
XW   = 0x85,
XSL  = 0x86,
XSW  = 0x87,

CALLSTACK_INSTRS = {XL, XW, XSL, XSW}

def waitForStart(io):
  buf = bytearray()
  while True:
    buf.clear()
    readexact(io, buf, 1)
    if buf[0] == 0x80:
      buf.clear(); readexact(io, buf, 1)
      if buf[0] == ZOAB_LOG:
        return
      print(f"??? Unknown byte after 0x80: {chr(buf[0])} ({nice(buf[0])})")
    else:
      c = 0
      try: chr(buf[0])
      except ValueError: pass
      print(f"??? Unknown byte: {chr(buf[0])} ({nice(buf[0])})")

SP_REGEX = re.compile(
  r'^#(?P<value>[\w_]+)\s+=(?P<name>.+)$',
  re.MULTILINE)

def findGlobals():
  glbls = {}

  for root, _, files in os.walk(".", topdown=False):
    for fname in files:
      if fname.endswith('.sp'): regex = SP_REGEX
      elif fname.endswith('.fn'): continue # TODO: not implemented yet
      else: continue

      with open(os.path.join(root, fname), 'r') as f:
        text = f.read()

      for m in re.finditer(regex, text):
        glbls[m.group('name')] = int(m.group('value'), 16)
  return glbls

def findErrorCodes(glbls):
  return {value: name for (name, value) in glbls.items()
          if name.startswith('E_')}

def sysEvent(env, z):
  control = z[0]
  sysTy = Lvl.TRACE.value & control[0]
  if sysTy == LOG_DICT:
    return DictEvent.from_(z, env)
  if sysTy == LOG_ERR:
    return ErrEvent.from_(z, env)
  if sysTy == LOG_FILE:
    return FileEvent.from_(z)
  if sysTy == LOG_JMP:
    return JmpEvent.from_(z, env)
  if sysTy == LOG_OP:
    return print("??? op", z)
  if sysTy == LOG_LIT:
    return print("??? lit", z)
  if sysTy == LOG_RET_SUCCESS:
    return RetSuccessEvent.from_(z, env)
  if sysTy == LOG_MEM:
    return print("??? mem", z)
  raise ValueError(f"Unknown sysTy: {nice(sysTy)}")

def inputs_stream(env, io):
  while True:
    waitForStart(io)
    z = zoa.from_zoab(io).to_py()
    if not z: continue
    control = z[0]
    if isinstance(control, int):
      print("?? got int control?"); continue

    if Lvl.SYS.value & control[0]:
      yield sysEvent(env, z)
      continue

    lvl = Lvl(control[0])
    payload = list(z[1:])

    yield BasicEvent(lvl=lvl, payload=payload)


@dataclass
class CallStkItem:
  ep: int
  fn: DictEvent
  fnNext: DictEvent
  localData: bytes

def orderFns(dicts):
  fns = []
  for d in dicts.values():
    for f in d.values():
      if f.isFn(): fns.append(f)

  fns.sort(key=DictEvent.ref)
  return fns

def findFnLesser(fns, addr):
  # A few notes:
  # - The ep that gets put on the call stack is the one where execution
  #   will CONTINUE.
  # - Therefore if the addr=fn.ref() then the previous function called
  #   something and bleeds into the next function on return
  #   (this may be intentional fall-through or they expect failure).
  if addr == 0: return None
  if fns[0].ref() > addr: return None
  if fns[-1].ref() < addr: return len(fns) - 1
  i = 0
  while i < len(fns):
    if fns[i].ref() >= addr:
      return i - 1
    i += 1

def getFnAndNext(fns, fnI):
  if fnI is None: return None, None
  fn, fnNext = fns[fnI], None
  if fnI < len(fns) - 1: fnNext = fns[fnI + 1]
  return fn, fnNext

def extractCallStack(fns, ev):
  out = []
  cs_i = 0
  ls_i = 0
  while cs_i < len(ev.callStk):
    lszRef = integerLE(ev.callStk[cs_i:cs_i+4])
    lszBytes = (lszRef >> 24) * 4
    ep = toRef(lszRef)
    lsData = ev.localsStk[ls_i:ls_i+lszBytes]
    fnI = findFnLesser(fns, ep)
    fn, fnNext = getFnAndNext(fns, fnI)
    out.append(CallStkItem(ep=ep, fn=fn, fnNext=fnNext, localData=lsData))

    cs_i += 4
    ls_i += lszBytes
  return out

def printCallStack(callStk):
  for i, item in enumerate(callStk):
    ep, key, ref = nice(item.ep), "BASE", 0
    if item.fn:
      key, ref = nice(item.fn.key), nice(item.fn.ref())
    loc = "in"
    if ref:
      loc = f"{item.ep - item.fn.ref():>5} bytes"
      if item.fnNext:
        p = (item.ep - item.fn.ref()) / (item.fnNext.ref() - item.fn.ref())
        p = int(100 * p)
        loc = loc + f" ({p:>3}%) into"
      else: loc += "        into"

    if i == 0: print("    Failure      ", end="")
    else:      print("    + Called from", end="")
    print(f" @{ep:<10} {loc} {key} (defined @{ref})")

def handleDictEvent(env, ev):
  env.dicts[ev.buf][ev.key] = ev
  if not ev.isConst:
    if ev.isLocal():
      env.currentFn.localOffsets[ev.localOffset()] = ev
    elif ev.isFn(): env.currentFn = ev

  if ev.isFn() and not ev.isLocal():
    env.fnLookup[ev.ref()] = nice(ev.key)

def handleErrEvent(env, ev):
  file = wantStr(env.file)

  if ev.isCaught: print(" -- Caught Error", end="")
  else:
    print(" !! ERROR", end="")
    env.uncaughtErr = ev

  print(f" (file: {file} [{ev.lineNo}])", end="")
  print(f" [{nice(ev.errCode)}] \"{ev.errName}\"  ")
  if len(ev.data) == 1:
    print("  V:", nice(ev.data[0]))
  if len(ev.data) == 2:
    print("  ERROR VALUES")
    print("    A:", nice(ev.data[0]))
    print("    B:", nice(ev.data[1]))

  print("Working Stk:", ev.ws)
  if   not ev.callStkLen: pass
  else:
    print(f"  Call Stack (depth={ev.callStkLen})")
    if not ev.callStk: return
    fns = orderFns(env.dicts)
    callStk = extractCallStack(fns, ev)
    lastFnI = findFnLesser(fns, ev.ep)
    fn, fnNext = getFnAndNext(fns, lastFnI)
    lastCs = CallStkItem(ep=ev.ep, fn=fn, fnNext=fnNext, localData=b'')
    callStk.insert(0, lastCs)
    printCallStack(callStk)


def harness(env, io):
  try:
    return _harness(env, io)
  except zoa.Eof: pass
  except Exception as e:
    ERRORS.append(e)
    raise

def _harness(env, io):
  """Harness for spor.

  Note: if using io=stdi, use stdin.buffer
    https://docs.python.org/3/library/sys.html#sys.stdin
  """

  for i, ev in enumerate(inputs_stream(env, io)):
    if ev is None: print(f"ev is none at i={i}"); continue
    if isinstance(ev, DictEvent):
      handleDictEvent(env, ev)
      continue
    if isinstance(ev, ErrEvent):
      handleErrEvent(env, ev)
      continue
    if isinstance(ev, FileEvent):
      env.file = ev.file
      continue
    if isinstance(ev, ExecutionEvent):
      print(ev)
      continue
    if isinstance(ev, BasicEvent) and ev.lvl == Lvl.USER:
      assert len(ev.payload) == 1 and isinstance(ev.payload[0], bytes), "invalid LOG_USER"
      print(ev.payload[0].decode('utf-8'), end="")
      continue

    print(f"{ev.lvl}[{i:>8d}]: ", end='')
    payload = ev.payload
    if len(payload) == 1: payload = payload[0]
    pprint.pprint(payload)

def compileSpore():
  print("Recompiling spore")
  subprocess.run(["gcc", "spor.c", "-o", "spor"], check=True)
  time.sleep(0.3) # For gcc error logging

def readPassLoop(inp, toOut):
  try:
    try: _readPassLoop(inp, toOut)
    except ValueError as e:
      if str(e) == 'I/O operation on closed file': pass
      else: raise
  except Exception as e:
    ERRORS.append(e)
    raise

def _readPassLoop(inp, toOut):
  """Reads from input and passes directly to output but is killable.

  Yes, this is really necessary to allow it to be killable. Yes, this complexity
  is all from python/linux/whatever.
  """
  writeBuf = bytearray()
  eof = False

  while not DONE:
    time.sleep(0.5)
    (rdRdy, wrRdy, xRdy) = select.select([inp.fileno()], [toOut.fileno()], [], 0.2)
    if rdRdy:
      b = os.read(inp.fileno(), 1024)
      print("[py]  Read:", b)
      if b: writeBuf.extend(b)
      else: eof = True

    if wrRdy and writeBuf:
      print("[py] Wrote:", writeBuf)
      written = os.write(toOut.fileno(), writeBuf)
      toOut.flush()
      writeBuf = writeBuf[written:]

    if eof and not writeBuf:
      return

def main():
  global DONE
  args = parser.parse_args()
  if args.compile: compileSpore()

  glbls = findGlobals()
  env = FngiEnv(
    dicts = collections.defaultdict(dict),
    fnLookup = {},
    glbls = glbls,
    codes = findErrorCodes(glbls),
    instrLookup = {
      value: key.split()[0] for key, value in glbls.items()
      if key.split()[0] in {
          'JMPL', 'JMPW', 'JZL', 'JTBL', 'XL', 'XW', 'XSL', 'XSW',
          'RET', 'RETZ'}
    },
  )

  usrLogLvl = '00'
  if args.log != 'LOG_SILENT':
    usrLogLvl = env.glbls[args.log]
    assert usrLogLvl <= 0xFF
    usrLogLvl = '{:02X}'.format(usrLogLvl)
  sysLogLvl = '00'
  if args.syslog != 'LOG_SILENT':
    sysLogLvl = env.glbls[args.syslog]
    assert sysLogLvl <= 0xFF
    sysLogLvl = '{:02X}'.format(sysLogLvl)

  cargs = [
    "./spor",
    "1" if args.test else "0",
    sysLogLvl,
    usrLogLvl,
  ]

  if args.valgrind: cargs.insert(0, 'valgrind')

  print("Running args:", cargs)
  p = subprocess.Popen(
      args=cargs,
      stdin=subprocess.PIPE,
      stdout=subprocess.PIPE,
      stderr=sys.stderr)

  procOut = CheckDoneReader(p.stdout)
  harnessTh = threading.Thread(target=harness, args=(env, procOut))
  readTh = threading.Thread(target=readPassLoop, args=(sys.stdin, p.stdin))
  try:
    harnessTh.start()
    readTh.start()
    while p.returncode is None and harnessTh.is_alive():
      time.sleep(0.2)
      p.poll()
  finally:
    # time.sleep(0.5) # Allow some time for buffers to flush
    DONE = True
    p.poll()

  if p.returncode:
    print("!! Got error rc:", p.returncode)
    sys.exit(p.returncode)
  if env.uncaughtErr:
    print("!!", env.uncaughtErr)

  if ERRORS:
    print("!! Got errors:", ERRORS)
    raise ERRORS[0]

if __name__ == '__main__':
  main()

  # env = FngiEnv(
  #   dicts = collections.defaultdict(dict),
  #   codes = findErrorCodes())
  # try:
  #   harness(env)
  # except zoa.Eof:
  #   print("Program terminated")
  # pprint.pprint(env.dicts)
  # for key, value in env.codes.items():
  #   print(f"  {nice(key)}: {value}")
