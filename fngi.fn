// Fngi bootstrap script: this script bootstraps the fngi language.
// Requires: spore.sp
//
// Note: at this stage the language is severely restricted and several
// pieces of the language are incomplete. Any CAPITAL items like FN, IF, LOOP
// etc do not behave in the way their lower-case counterparts will behave.
// Refer to spor.sp for all documentation.

$c_fngi

// Stack operators. These are /not/ PRE since they directly modify the stack.
SFN swp      SMART IF() spor%SWP    ELSE $c1(SWP )   END ret;
SFN drp      SMART IF() spor%DRP    ELSE $c1(DRP )   END ret;
SFN ovr      SMART IF() spor%OVR    ELSE $c1(OVR )   END ret;
SFN dup      SMART IF() spor%DUP    ELSE $c1(DUP )   END ret;
SFN dupn     SMART IF() spor%DUPN   ELSE $c1(DUPN)   END ret;

// Standard operators that use PRE syntax
SFN dvft PRE SMART IF() spor%DVFT   ELSE $c1(DVFT)   END ret;
SFN dvsr PRE SMART IF() spor%DVSR   ELSE $c1(DVSR)   END ret;
SFN inc  PRE SMART IF() spor%INC    ELSE $c1(INC )   END ret;
SFN inc2 PRE SMART IF() spor%INC2   ELSE $c1(INC2)   END ret;
SFN inc4 PRE SMART IF() spor%INC4   ELSE $c1(INC4)   END ret;
SFN dec  PRE SMART IF() spor%DEC    ELSE $c1(DEC )   END ret;
SFN inv  PRE SMART IF() spor%INV    ELSE $c1(INV )   END ret;
SFN neg  PRE SMART IF() spor%NEG    ELSE $c1(NEG )   END ret;
SFN not  PRE SMART IF() spor%NOT    ELSE $c1(NOT )   END ret;
SFN i1to4 PRE SMART IF() spor%CI1    ELSE $c1(CI1 )   END ret;
SFN i2to4 PRE SMART IF() spor%CI2    ELSE $c1(CI2 )   END ret;

SFN +    PRE SMART IF() spor%ADD    ELSE $c1(ADD )   END ret;
SFN -    PRE SMART IF() spor%SUB    ELSE $c1(SUB )   END ret;
SFN %    PRE SMART IF() spor%MOD    ELSE $c1(MOD )   END ret;
SFN <<   PRE SMART IF() spor%SHL    ELSE $c1(SHL )   END ret;
SFN >>   PRE SMART IF() spor%SHR    ELSE $c1(SHR )   END ret;
SFN bAnd PRE SMART IF() spor%BAND   ELSE $c1(BAND)   END ret;
SFN bOr  PRE SMART IF() spor%BOR    ELSE $c1(BOR )   END ret;
SFN xor  PRE SMART IF() spor%XOR    ELSE $c1(XOR )   END ret;
SFN lAnd PRE SMART IF() spor%LAND   ELSE $c1(LAND)   END ret;
SFN lOr  PRE SMART IF() spor%LOR    ELSE $c1(LOR )   END ret;
SFN ==   PRE SMART IF() spor%EQ     ELSE $c1(EQ  )   END ret;
SFN !=   PRE SMART IF() spor%NEQ    ELSE $c1(NEQ )   END ret;
SFN >=   PRE SMART IF() spor%GE_U   ELSE $c1(GE_U)   END ret;
SFN <    PRE SMART IF() spor%LT_U   ELSE $c1(LT_U)   END ret;
SFN *    PRE SMART IF() spor%MUL    ELSE $c1(MUL )   END ret;
SFN /    PRE SMART IF() spor%DIV_U  ELSE $c1(DIV_U ) END ret;

SFN xsw  PRE SMART assertNoInstant $c1(SZA+XSW) ret;
SFN xw   PRE SMART assertNoInstant $c1(SZA+XW)  ret;

// ftN(addr): fetch a value of sz N from address.
SFN ft1    PRE SMART IF() spor$(.1%FT) ELSE $c1(SZ1+FT) END ret;
SFN ft2    PRE SMART IF() spor$(.2%FT) ELSE $c1(SZ2+FT) END ret;
SFN ft4    PRE SMART IF() spor$(.4%FT) ELSE $c1(SZ4+FT) END ret;

// srN(addr, value): store a value of sz N to address.
SFN sr1    PRE SMART IF() spor$(.1%SR) ELSE $c1(SZ1+SR) END ret;
SFN sr2    PRE SMART IF() spor$(.2%SR) ELSE $c1(SZ2+SR) END ret;
SFN sr4    PRE SMART IF() spor$(.4%SR) ELSE $c1(SZ4+SR) END ret;

SFN = SMART drp panic(E_cToken) // prevent hanging =
SFN ) SMART drp panic(E_cUnclosed) // prevent unclosed parens
SFN setSysLogLvl PRE _SET sysLogLvl ret; // {logLvl}
SFN setUsrLogLvl PRE _SET usrLogLvl ret; // {logLvl}
SFN memCmp  PRE  ret dvft(D_memCmp) // {&a &b len -> cmp}
SFN memSet  PRE  ret dvft(D_memSet) // {dst v len}   "dst = v"
SFN memMove PRE  ret dvsr(D_memSet) // {dst src len} "dst = src"

SFN c_shiftBuf // shift buffer to clear current token
  (GET c_tokenBuf, dup + GET c_tokenLen, GET c_tokenLen)
  $jmpl memMove

// FN_REF <function>: &fn (as literal or instant)
SFN FN_REF   SMART
  dictGetR; assertTyped(dup) // {asInst &metaRef}
  ft4(_)    assertFn(dup)    // {asInst metaRef}
  toRef(_)  swp              // {&fn asInst}
  ret(IF(_) _ ELSE lit(_) END)

FN strEq PRE // {aLen &a bLen &b}
  // $SZ2 INPUT aLen $SZ4 INPUT a
  $SZ2 INPUT bLen  $SZ4 INPUT b END_LOCALS
  swp // {&a aLen}
  IF(_ != GET bLen)  drp; ret FALSE;  END // {&a}
  ret(memCmp(_, GET b, GET bLen) == 0)

SFN assertToken PRE // {zStr}
  ft1(dup) swp; inc(_) // {expectLen &expect}
  strEq(_, _, GET c_tokenLen, GET c_tokenBuf)
  (_, E_cNeedToken) $jmpl assert

$loc TOKEN_EQ | =|

SFN CONST  SMART assertNoInstant // CONST <name> = <value>
  c_updateRKey; loc; // {&key}: update c_rKey and initialize dict@name
  c_scan; assertToken(TOKEN_EQ) // {&key}: expect "="
  ret sr4(_, assert(c_number, E_cNeedNumber)) // store number at &key

FN SET  SMART // SET <name> = <value>
  $SZ4 LOCAL rMetaRef  $SZ1 LOCAL isFromLocal END_LOCALS
  assertNoInstant;
  c_scan; anyDictGetR;  _SET isFromLocal  _SET rMetaRef // cache <name>
  c_scan; assertToken(TOKEN_EQ) // "SET name ="
  xw(GET c_compFn) // <value>
  ret _setImpl(GET rMetaRef, GET isFromLocal)

FN gheapReserve PRE  $SZ2 INPUT len END_LOCALS
  memSet(GET c_gheap, 0, GET len) // clear bytes
  SET c_gheap = (GET c_gheap + GET len);
  ret;

FN /*  // block-comment */
  $SZ1 LOCAL lastTy // 0=*, 1=/  2=other
  $SZ1 LOCAL c
  END_LOCALS SMART drp; // ignore asInstant
  SET lastTy = 2; // other
  LOOP l0
    IF(GET c_tokenLen >= GET c_tokenSize)  c_assertNoEof(c_readNew)  END
    GET c_tokenLen; // {c_tokenLen}
    SET c = ft1(dup + GET c_tokenBuf); // {c_tokenLen}
    SET c_tokenLen = inc(_); // increment c_tokenLen

    IF(0c/ == GET c)
      retz(GET lastTy) // Found: */ (done)
      SET lastTy = 1; // lastTy=/
    ELSE IF(0c* == GET c)
      IF(1 == GET lastTy) // Found: /*
        FALSE spor$xl /* // recursively call block-comment. */
      ELSE  SET lastTy = 0;  END
    ELSE  SET lastTy = 2;    END END
  AGAIN l0

FN between PRE // {value a b -> bool} value is between [a b)
  $SZ4 INPUT b   END_LOCALS // {value a}
  ovr; swp; // {value value a}
  IF(_ < _)  drp; ret FALSE;  END // {value}: if(value<a) do ret FALSE
  GET b; ret(_ < _); // ret(value < b)

// **********
// * Block Allocator (BA)
// The Block Allocator (BA) is used to allocate and free 4KiB blocks. It can
// store up to 255 of them (almost a full MiB).
//
// It's implementation architecture is built on the Byte Singly Linked List
// (BSLL). The structure of a BSLL is an array of bytes, up to length 255.
// Each byte can contain either 0xFF (BA_iNull) or the index of the next node.
// At initialization, the root points to the first index and each index
// points to the next index. Allocation is then simply popping indexes
// from the SLL.
//
// STRUCT BA [ // size=10
//   indexes: &U1;   // 0: pointer to indexes (up to 255 bytes)
//   blocks: APtr;   // 4: pointer to data blocks, each of 4KiB
//   len: U1;        // 5: number of indexes and blocks
//   root: U1;       // 6: root free block, may be 0xFF if empty
// ]

CONST NULL = 0;
CONST BA_iNull = 0xFF;
CONST BA_blockPo2 = 12;  // 4KiB == 2^12

// STRUCT BA
//    BA_indexesOfs = 0;  // indexes: APtr
CONST BA_blocksOfs  = 4;  // blocks: APtr
CONST BA_lenOfs     = 9;  // len: U1
CONST BA_rootOfs    = 10; // root: U1

SFN BA_iToPtr PRE // {bi &ba -> &block}
  ft4(_ + BA_blocksOfs); swp;            // {&firstBlock bi}
  IF(dup == BA_iNull) drp; ret NULL; END // {&firstBlock bi}
  ret(_ + (_ << BA_blockPo2))

FN BA_ptrToI PRE // {&block &ba -> bi}
  $SZ4 INPUT block  $SZ4 INPUT ba  END_LOCALS
  IF(not GET block)  ret BA_iNull;  END
  assert(
    between( // block between [&firstBlock, &lastBlockEnd)
      GET block,
      ft4(GET ba + BA_blocksOfs), // {&firstBlock}
      dup + (inc(ft1(GET ba + BA_lenOfs)) << BA_blockPo2),
    ), E_iBlock)
  ret(GET block - ft4(GET ba + BA_blocksOfs));

SFN BA_iGet  PRE ret ft1(_ + ft4(_)) // {bi &ba -> bi}
SFN BA_iSet  PRE  // {value bi &ba}  set ba@bi = value
  _ + ft4(_) // {value &index}
  swp; ret sr1(_, _)

FN BA_init PRE // {&ba}
  $SZ4 INPUT ba  $SZ1 LOCAL iLast  END_LOCALS
  SET iLast = dec(ft1(GET ba + BA_lenOfs));
  sr1(GET ba + BA_rootOfs, 0); // initialze root as index=0
  0 LOOP l0 // {bi}
    IF (dup == GET iLast)
      BA_iNull; swp; // {BA_iNull bi}
      ret BA_iSet(_, _, GET ba)
    END // {bi}
    dup; dup; inc(_); swp; // {bi bi+1 bi}
    BA_iSet(_, _, GET ba)
    inc(_) // {bi+1}
  AGAIN l0

// $setSysLogLvl(LOG_EXECUTE)
$BA_init(REF BA_kernel)

// { &ba -> bi} alocate a block index
// (returning a) root->a->b ===> root->b
FN BA_iAlloc PRE
  $SZ4 INPUT ba  $SZ1 LOCAL out  END_LOCALS
  ft1(GET ba + BA_rootOfs) // {biRoot}
  reteq(dup, BA_iNull) // return BA_iNull if biRoot=BA_iNull
  SET out = _; // out=biRoot
  sr1(GET ba + BA_rootOfs, BA_iGet(GET out, GET ba)); // root=next node
  ret GET out;

// {bi &ba} free a block index
// (freeing bi=a) root->b  ===>  root->a->b
FN BA_iFree PRE
  $SZ1 INPUT bi  $SZ1 LOCAL biRoot  $SZ4 INPUT ba  END_LOCALS
  assert(BA_iNull != GET bi, E_iBlock)
  SET biRoot = ft1(GET ba + BA_rootOfs)
  BA_iSet(GET biRoot, GET bi, GET ba)  // a -> b  (note: may be BA_iNull)
  ret sr1(GET ba + BA_rootOfs, GET bi) // root -> a

SFN BA_alloc PRE ret BA_iToPtr(BA_iAlloc(_)); // {&ba -> &blockNullable}
SFN BA_free  PRE // {&block &ba}
  swp; ovr; // {&ba &block &ba}
  BA_ptrToI(_); swp; // {bi &ba}
  ret BA_iFree(_, _);

$c_dictDump
