// Fngi bootstrap script: this script bootstraps the fngi language.
// Requires: spore.sp
//
// Note: at this stage the language is severely restricted and several
// pieces of the language are incomplete. Any CAPITAL items like FN, IF, LOOP
// etc do not behave in the way their lower-case counterparts will behave.
// Refer to spor.sp for all documentation.

$c_fngi

// Stack operators. These are /not/ PRE since they directly modify the stack.
SFN swp      SMART IF() spor%SWP    ELSE $c1(SWP )   END ret;
SFN drp      SMART IF() spor%DRP    ELSE $c1(DRP )   END ret;
SFN ovr      SMART IF() spor%OVR    ELSE $c1(OVR )   END ret;
SFN dup      SMART IF() spor%DUP    ELSE $c1(DUP )   END ret;
SFN dupn     SMART IF() spor%DUPN   ELSE $c1(DUPN)   END ret;

// Standard operators that use PRE syntax
SFN dvft PRE SMART IF() spor%DVFT   ELSE $c1(DVFT)   END ret;
SFN dvsr PRE SMART IF() spor%DVSR   ELSE $c1(DVSR)   END ret;
SFN inc  PRE SMART IF() spor%INC    ELSE $c1(INC )   END ret;
SFN inc2 PRE SMART IF() spor%INC2   ELSE $c1(INC2)   END ret;
SFN inc4 PRE SMART IF() spor%INC4   ELSE $c1(INC4)   END ret;
SFN dec  PRE SMART IF() spor%DEC    ELSE $c1(DEC )   END ret;
SFN inv  PRE SMART IF() spor%INV    ELSE $c1(INV )   END ret;
SFN neg  PRE SMART IF() spor%NEG    ELSE $c1(NEG )   END ret;
SFN not  PRE SMART IF() spor%NOT    ELSE $c1(NOT )   END ret;
SFN i1to4 PRE SMART IF() spor%CI1    ELSE $c1(CI1 )   END ret;
SFN i2to4 PRE SMART IF() spor%CI2    ELSE $c1(CI2 )   END ret;

SFN +    PRE SMART IF() spor%ADD    ELSE $c1(ADD )   END ret;
SFN -    PRE SMART IF() spor%SUB    ELSE $c1(SUB )   END ret;
SFN %    PRE SMART IF() spor%MOD    ELSE $c1(MOD )   END ret;
SFN <<   PRE SMART IF() spor%SHL    ELSE $c1(SHL )   END ret;
SFN >>   PRE SMART IF() spor%SHR    ELSE $c1(SHR )   END ret;
SFN bAnd PRE SMART IF() spor%BAND   ELSE $c1(BAND)   END ret;
SFN bOr  PRE SMART IF() spor%BOR    ELSE $c1(BOR )   END ret;
SFN xor  PRE SMART IF() spor%XOR    ELSE $c1(XOR )   END ret;
SFN lAnd PRE SMART IF() spor%LAND   ELSE $c1(LAND)   END ret;
SFN lOr  PRE SMART IF() spor%LOR    ELSE $c1(LOR )   END ret;
SFN ==   PRE SMART IF() spor%EQ     ELSE $c1(EQ  )   END ret;
SFN !=   PRE SMART IF() spor%NEQ    ELSE $c1(NEQ )   END ret;
SFN >=   PRE SMART IF() spor%GE_U   ELSE $c1(GE_U)   END ret;
SFN <    PRE SMART IF() spor%LT_U   ELSE $c1(LT_U)   END ret;
SFN *    PRE SMART IF() spor%MUL    ELSE $c1(MUL )   END ret;
SFN /    PRE SMART IF() spor%DIV_U  ELSE $c1(DIV_U ) END ret;

SFN xsw  PRE SMART assertNoInstant $c1(SZA+XSW) ret;
SFN xw   PRE SMART assertNoInstant $c1(SZA+XW)  ret;

// ftN(addr): fetch a value of sz N from address.
SFN ft1    PRE SMART IF() spor$(.1%FT) ELSE $c1(SZ1+FT) END ret;
SFN ft2    PRE SMART IF() spor$(.2%FT) ELSE $c1(SZ2+FT) END ret;
SFN ft4    PRE SMART IF() spor$(.4%FT) ELSE $c1(SZ4+FT) END ret;

// srN(addr, value): store a value of sz N to address.
SFN sr1    PRE SMART IF() spor$(.1%SR) ELSE $c1(SZ1+SR) END ret;
SFN sr2    PRE SMART IF() spor$(.2%SR) ELSE $c1(SZ2+SR) END ret;
SFN sr4    PRE SMART IF() spor$(.4%SR) ELSE $c1(SZ4+SR) END ret;

SFN = SMART drp panic(E_cToken) // prevent hanging =
SFN ) SMART drp panic(E_cUnclosed) // prevent unclosed parens
SFN setSysLogLvl PRE _SET sysLogLvl ret; // {logLvl}
SFN setUsrLogLvl PRE _SET usrLogLvl ret; // {logLvl}
SFN memcmp PRE  ret dvft(D_memCmp) // {&a &b len -> cmp}
SFN memMove PRE  ret dvft(D_memMove) // {dst src len} "dst = src"

SFN c_shiftBuf // shift buffer to clear current token
  (GET c_tokenBuf, dup + GET c_tokenLen, GET c_tokenLen)
  $jmpl memMove

// FN_REF <function>: &fn (as literal or instant)
SFN FN_REF   SMART
  dictGetR; assertTyped(dup) // {asInst &metaRef}
  ft4(_)    assertFn(dup)    // {asInst metaRef}
  toRef(_)  swp              // {&fn asInst}
  ret(IF(_) _ ELSE lit(_) END)

FN strEq PRE // {aLen &a bLen &b}
  // $SZ2 INPUT aLen $SZ4 INPUT a
  $SZ2 INPUT bLen  $SZ4 INPUT b END_LOCALS
  swp // {&a aLen}
  IF(_ != GET bLen)  drp; ret FALSE;  END // {&a}
  ret(memcmp(_, GET b, GET bLen) == 0)

SFN assertToken PRE // {zStr}
  ft1(dup) swp; inc(_) // {expectLen &expect}
  strEq(_, _, GET c_tokenLen, GET c_tokenBuf)
  (_, E_cNeedToken) $jmpl assert

$loc TOKEN_EQ | =|

SFN CONST  SMART assertNoInstant // CONST <name> = <value>
  c_updateRKey; loc; // {&key}: update c_rKey and initialize dict@name
  c_scan; assertToken(TOKEN_EQ) // {&key}: expect "="
  ret sr4(_, assert(c_number, E_cNeedNumber)) // store number at &key

FN SET  SMART // SET <name> = <value>
  $SZ4 LOCAL rMetaRef  $SZ1 LOCAL isFromLocal END_LOCALS
  assertNoInstant;
  c_scan; anyDictGetR;  _SET isFromLocal  _SET rMetaRef // cache <name>
  c_scan; assertToken(TOKEN_EQ) // "SET name ="
  xw(GET c_compFn) // <value>
  ret _setImpl(GET rMetaRef, GET isFromLocal)

// **********
// * Block Allocator (BA)
// The Block Allocator (BA) is built on the Byte Singly Linked List (BSLL).
//
// The structure of a BSLL is an array of bytes, up to length 255. Each byte
// can contain either 0xFF ("null") or the index of the next node. The root
// node is then stored by either the root "free allocator", who's nodes are
// blocks available to be used; or an "owned allocator" containing allocated
// blocks.
//
// STRUCT BSLL [
//   indexes: &U1;   // 0: pointer to indexes (up to 255 bytes)
//   blocks: APtr;   // 4: pointer to data blocks, each of 4KiB
//   len: U1;        // 5: number of indexes and blocks
//   root: U1;       // 6: root free block, may be 0xFF if empty.
// ]

CONST BA_null = 0xFF;

SFN BA_allocI // { &ba -> blockIndex}

SFN BA_alloc // { &ba -> &block}


// **********
// * Block Allocator


$c_dictDump
