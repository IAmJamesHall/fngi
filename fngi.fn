\ Fngi: bootstraps the fngi language.
\ Requires: spore.sp
\
\ Note: at this stage the language is severely restricted and several
\ pieces of the language are incomplete. Any CAPITAL items like FN, IF, LOOP
\ etc do not behave in the way their lower-case counterparts will behave.
\ Refer to spor.sp for all documentation.

$c_fngi

\ Stack operators. These are /not/ PRE since they directly modify the stack.
FN swp      SYN IF() spor%SWP    ELSE $c1(SWP )   END ret;
FN drp      SYN IF() spor%DRP    ELSE $c1(DRP )   END ret;
FN ovr      SYN IF() spor%OVR    ELSE $c1(OVR )   END ret;
FN dup      SYN IF() spor%DUP    ELSE $c1(DUP )   END ret;
FN dupn     SYN IF() spor%DUPN   ELSE $c1(DUPN)   END ret;

\ Standard operators that use PRE syntax
FN dvft PRE SYN IF() spor%DVFT   ELSE $c1(DVFT)   END ret;
FN dvsr PRE SYN IF() spor%DVSR   ELSE $c1(DVSR)   END ret;
FN inc  PRE SYN IF() spor%INC    ELSE $c1(INC )   END ret;
FN inc2 PRE SYN IF() spor%INC2   ELSE $c1(INC2)   END ret;
FN inc4 PRE SYN IF() spor%INC4   ELSE $c1(INC4)   END ret;
FN dec  PRE SYN IF() spor%DEC    ELSE $c1(DEC )   END ret;
FN inv  PRE SYN IF() spor%INV    ELSE $c1(INV )   END ret;
FN neg  PRE SYN IF() spor%NEG    ELSE $c1(NEG )   END ret;
FN not  PRE SYN IF() spor%NOT    ELSE $c1(NOT )   END ret;
FN i1to4 PRE SYN IF() spor%CI1    ELSE $c1(CI1 )  END ret;
FN i2to4 PRE SYN IF() spor%CI2    ELSE $c1(CI2 )  END ret;

FN +    PRE SYN IF() spor%ADD    ELSE $c1(ADD )   END ret;
FN -    PRE SYN IF() spor%SUB    ELSE $c1(SUB )   END ret;
FN %    PRE SYN IF() spor%MOD    ELSE $c1(MOD )   END ret;
FN <<   PRE SYN IF() spor%SHL    ELSE $c1(SHL )   END ret;
FN >>   PRE SYN IF() spor%SHR    ELSE $c1(SHR )   END ret;
FN msk  PRE SYN IF() spor%MSK    ELSE $c1(MSK)    END ret;
FN jn   PRE SYN IF() spor%JN     ELSE $c1(JN  )   END ret;
FN xor  PRE SYN IF() spor%XOR    ELSE $c1(XOR )   END ret;
FN and  PRE SYN IF() spor%AND    ELSE $c1(AND)    END ret;
FN or   PRE SYN IF() spor%OR     ELSE $c1(OR  )   END ret;
FN ==   PRE SYN IF() spor%EQ     ELSE $c1(EQ  )   END ret;
FN !=   PRE SYN IF() spor%NEQ    ELSE $c1(NEQ )   END ret;
FN >=   PRE SYN IF() spor%GE_U   ELSE $c1(GE_U)   END ret;
FN <    PRE SYN IF() spor%LT_U   ELSE $c1(LT_U)   END ret;
FN *    PRE SYN IF() spor%MUL    ELSE $c1(MUL )   END ret;
FN /    PRE SYN IF() spor%DIV_U  ELSE $c1(DIV_U ) END ret;

FN xsw  PRE SYN assertNoNow(_) $c1(SZA+XSW) ret;
FN xw   PRE SYN assertNoNow(_) $c1(SZA+XW)  ret;


\ memSet: {dst v len}   "dst = v"
\ memMove {dst src len} "dst = src"
\ memCmp: {&a &b len -> cmp}
FN memSet  PRE SYN IF() dvft(D_memSet) ELSE lit(D_memSet) $c1(DVFT) END ret;
FN memMove PRE SYN IF() dvsr(D_memSet) ELSE lit(D_memSet) $c1(DVSR) END ret;
FN memCmp  PRE SYN IF() dvft(D_memCmp) ELSE lit(D_memCmp) $c1(DVFT) END ret;
FN memClear PRE  0 swp; ret memSet(_, _) \ {addr len} clear memory

\ {a b} return if a < b
FN retlt PRE SYN assertNoNow(_) $c1(GE_U) $c1(RETZ) ret;

\ ftN(addr): fetch a value of sz N from address.
FN ft1    PRE SYN IF() spor$(.1%FT) ELSE $c1(SZ1+FT) END ret;
FN ft2    PRE SYN IF() spor$(.2%FT) ELSE $c1(SZ2+FT) END ret;
FN ft4    PRE SYN IF() spor$(.4%FT) ELSE $c1(SZ4+FT) END ret;

\ srN(value, addr): store a value of sz N to address.
FN sr1    PRE SYN IF() spor$(.1%SR) ELSE $c1(SZ1+SR) END ret;
FN sr2    PRE SYN IF() spor$(.2%SR) ELSE $c1(SZ2+SR) END ret;
FN sr4    PRE SYN IF() spor$(.4%SR) ELSE $c1(SZ4+SR) END ret;

FN = SYN drp panic(E_cToken)    \ prevent hanging =
FN ) SYN drp panic(E_cUnclosed) \ prevent hanging )
FN setSysLogLvl PRE _SET sysLogLvl ret; \ {logLvl}
FN setUsrLogLvl PRE _SET usrLogLvl ret; \ {logLvl}


FN c_alias PRE \ {&key, isLocal, meta}


\ TODO: alias?
$(select(REF sr2, REF sr4, ASIZE == 2) -> (TY_FN_PRE + TY_FN_SYN) gdictSet srA)
$(select(REF sr2, REF sr4, ASIZE == 2) -> (TY_FN_PRE + TY_FN_SYN) gdictSet ftA)

FN strEq PRE \ {aLen &a bLen &b}
  $declVar(declL bLen, TY_VAR_INPUT+SZA, ASIZE)
  $declVar(declL b, TY_VAR_INPUT+SZA, ASIZE)
  $declEnd
  swp \ {&a aLen}
  IF(\aLen != GET bLen)  drp; ret FALSE;  END \ {&a}
  ret(memCmp(\a, GET b, GET bLen) == 0)

FN zEq PRE \ {&aZ &bZ} compare two zoab strings
  $declVar(declL bZ, TY_VAR_INPUT+SZA, ASIZE) $declEnd
         ft1(dup) -> swp -> inc; \ {aLen &a}
  GET bZ ft1(dup) -> swp -> inc; \ {aLen &a bLen &b}
  -> ret strEq;

\ $loc TOKEN_COMMA  | ,|
\ $loc TOKEN_SEMI   | ;|
\ $loc TOKEN_ARROW  | ->|
\ FN c_isComment \ [ -> bool] return true if token is a comment
\   TRUE -> retif (ft1(GET c_tokenBuf) == 0c\\)
\           \ retif(zEq(GET c_tokenLen, TOKEN_COMMA))
\           \ retif(zEq(GET c_tokenLen, TOKEN_SEMI))
\           \ retif(zEq(GET c_tokenLen, TOKEN_ARROW))
\   drp; ret(FALSE)
\ 
\ FN skipComments \ skip any comments in tokens.
\   LOOP l0  retif(ft1(GET c_tokenBuf) != 0c\\)
\     c_single(FALSE); c_scanNoEof;  AGAIN l0
\ 
\ FN eqToken PRE \ [&zStr -> bool]
\   skipComments;
\   ft1(dup); swp; inc(\zStr) \ {expectLen &expect}
\   ret strEq(\(expectLen, &expect), GET c_tokenLen, GET c_tokenBuf)
\ FN assertToken PRE \(&zStr) eqToken(_), E_cNeedToken -> $jmpl assert
\ 
\ $loc TOKEN_EQ | =|
\ FN CONST  SYN assertNoNow(_) \ CONST <name> = <value>
\   c_updateGkey; loc; \ {&key}: update c_gkey and initialize dict@name
\   c_scan; assertToken(TOKEN_EQ) \ {&key}: expect "="
\   c_now; \ compile next token as NOW (like it was $)
\   swp; ret sr4(\num, \(&key));
\ 
\ FN between PRE \ {value a b -> bool} value is between [a b)
\   $declVar(declL b, TY_VAR_INPUT+SZA, ASIZE) $declEnd \ {value a}
\   ovr; swp; \ {value value a}
\   IF(\value < \a)  drp; ret FALSE;  END
\   ret(\value < GET b);
\ 
\ FN elif unreach;  FN else unreach;
\ 
\ $loc TOKEN_DO   |do|
\ $loc TOKEN_ELIF |elif|
\ $loc TOKEN_ELSE |else|
\ 
\ \ Note: if mapping. We use recursion to store h.
\ \ if <token>   do <token>  ->  IF <token>       <token>
\ \ elif <token> do <token>  ->  ELSE <token> IF  <token>
\ \ else            <token>  ->  ELSE             <token>
\ \                              END END END
\ FN
\ _if
\ \ [] recursive function of `if`
\ $assertWsEmpty \ UUUUU
\ 
\ $
\ declVar(declL h, SZA, ASIZE) $declEnd
\   c_single(c_scan; FALSE) \ compile token after if
\   0 -> $xsl IF -> _SET h
\   assertToken(c_scan; TOKEN_DO) c_single(c_scan; FALSE) \ do <token>
\   c_scan;
\   IF(eqToken(TOKEN_ELIF))       GET h, 0 -> $xsl ELSE -> _SET h;  _if;
\   ELSE IF(eqToken(TOKEN_ELSE))
\     GET h, 0 -> $xsl ELSE -> _SET h;  c_single(c_scan; FALSE)
\   ELSE  0 -> _SET c_tokenLen \ else: only peek
\   END END  ret _END(GET h)
\ 
\ \ if <token> do <token>  elif <token> do <token>  else <token>
\ FN if SYN assertNoNow(_); ret _if();
\ 
\ $loc TOKEN_BRK_O |[|
\ $loc TOKEN_BRK_C |]|
\ FN ufn SYN \ ufn <token> [ <inputs> -> <locals> ] do ( <code> )
\   assertNoNow(_)
\   0 -> $xsl FN \ declare function
\   c_scan;
\ 
