// Fngi bootstrap script: this script bootstraps the fngi language.
// Requires: spore.sp

$c_fngi

// Stack operators. These are /not/ PRE since they directly modify the stack.
SFN swp      SMART IF() spor%SWP    ELSE $c1(SWP )   END ret;
SFN drp      SMART IF() spor%DRP    ELSE $c1(DRP )   END ret;
SFN ovr      SMART IF() spor%OVR    ELSE $c1(OVR )   END ret;
SFN dup      SMART IF() spor%DUP    ELSE $c1(DUP )   END ret;
SFN dupn     SMART IF() spor%DUPN   ELSE $c1(DUPN)   END ret;

// Standard operators that use PRE syntax
SFN dvft PRE SMART IF() spor%DVFT   ELSE $c1(DVFT)   END ret;
SFN dvsr PRE SMART IF() spor%DVSR   ELSE $c1(DVSR)   END ret;
SFN inc  PRE SMART IF() spor%INC    ELSE $c1(INC )   END ret;
SFN inc2 PRE SMART IF() spor%INC2   ELSE $c1(INC2)   END ret;
SFN inc4 PRE SMART IF() spor%INC4   ELSE $c1(INC4)   END ret;
SFN dec  PRE SMART IF() spor%DEC    ELSE $c1(DEC )   END ret;
SFN inv  PRE SMART IF() spor%INV    ELSE $c1(INV )   END ret;
SFN neg  PRE SMART IF() spor%NEG    ELSE $c1(NEG )   END ret;
SFN not  PRE SMART IF() spor%NOT    ELSE $c1(NOT )   END ret;
SFN i1to4 PRE SMART IF() spor%CI1    ELSE $c1(CI1 )   END ret;
SFN i2to4 PRE SMART IF() spor%CI2    ELSE $c1(CI2 )   END ret;

SFN +    PRE SMART IF() spor%ADD    ELSE $c1(ADD )   END ret;
SFN -    PRE SMART IF() spor%SUB    ELSE $c1(SUB )   END ret;
SFN %    PRE SMART IF() spor%MOD    ELSE $c1(MOD )   END ret;
SFN <<   PRE SMART IF() spor%SHL    ELSE $c1(SHL )   END ret;
SFN >>   PRE SMART IF() spor%SHR    ELSE $c1(SHR )   END ret;
SFN bAnd PRE SMART IF() spor%BAND   ELSE $c1(BAND)   END ret;
SFN bOr  PRE SMART IF() spor%BOR    ELSE $c1(BOR )   END ret;
SFN xor  PRE SMART IF() spor%XOR    ELSE $c1(XOR )   END ret;
SFN lAnd PRE SMART IF() spor%LAND   ELSE $c1(LAND)   END ret;
SFN lOr  PRE SMART IF() spor%LOR    ELSE $c1(LOR )   END ret;
SFN ==   PRE SMART IF() spor%EQ     ELSE $c1(EQ  )   END ret;
SFN !=   PRE SMART IF() spor%NEQ    ELSE $c1(NEQ )   END ret;
SFN >=   PRE SMART IF() spor%GE_U   ELSE $c1(GE_U)   END ret;
SFN <    PRE SMART IF() spor%LT_U   ELSE $c1(LT_U)   END ret;
SFN *    PRE SMART IF() spor%MUL    ELSE $c1(MUL )   END ret;
SFN /    PRE SMART IF() spor%DIV_U  ELSE $c1(DIV_U ) END ret;

SFN xsw  PRE SMART assertNoInstant $c1(SZA+XSW) ret;
SFN xw   PRE SMART assertNoInstant $c1(SZA+XW)  ret;

// ftN(REF name): fetch a value of sz N from reference.
SFN ft1    PRE SMART IF() spor$(.1%FT) ELSE $c1(SZ1+FT) END ret;
SFN ft2    PRE SMART IF() spor$(.2%FT) ELSE $c1(SZ2+FT) END ret;
SFN ft4    PRE SMART IF() spor$(.4%FT) ELSE $c1(SZ4+FT) END ret;

// srN(REF name, value): store a value of sz N to reference
SFN sr1    PRE SMART IF() spor$(.1%SR) ELSE $c1(SZ1+SR) END ret;
SFN sr2    PRE SMART IF() spor$(.2%SR) ELSE $c1(SZ2+SR) END ret;
SFN sr4    PRE SMART IF() spor$(.4%SR) ELSE $c1(SZ4+SR) END ret;

SFN setSysLogLvl PRE _SET sysLogLvl ret; // {logLvl}
SFN setUsrLogLvl PRE _SET usrLogLvl ret; // {logLvl}

$setSysLogLvl(LOG_EXECUTE)

// FN_REF <function>: &fn (as literal or instant)
SFN FN_REF   SMART
  dictGetR; assertTyped(dup) // {asInst &metaRef}
  ft4(_)    assertFn(dup)    // {asInst metaRef}
  toRef(_)  swp              // {&fn asInst}
  ret(IF(_) _ ELSE lit(_) END)

// memMove(dst, src len)
// Conceptually think of as "dst = src" (of len)
SFN memMove PRE  ret dvft(D_memMove) // {dst src len} -> {}

SFN c_shiftBuf // shift buffer to clear current token
  (GET c_tokenBuf, dup + GET c_tokenLen, GET c_tokenLen)
  $jmpl memMove

FN SET  SMART // SET name value
  $SZ4 LOCAL rMetaRef  $SZ1 LOCAL isFromLocal END_LOCALS
  assertNoInstant
  c_scan  anyDictGetR  _SET isFromLocal  _SET rMetaRef
  xw(GET c_compFn)
  ret _setImpl(GET rMetaRef, GET isFromLocal)

// TODO: it seems like INSTANT might be broken now?
// Block comment, allows /*nesting*/.
// SFN /*  // */
//   INSTANT
//   LOOP l
//     c_scan   assert(GET c_tokenLen, E_eof)
//     IF(GET c_tokenLen < 2) AGAIN l
// 
//     ft1(GET c_tokenBuf) == '/'
//       or ft1(inc GET c_tokenBuf) == '*';
//     IF _ ret
//   AGAIN l


// SFN cbytesUnpack PRE // {&cbytes} -> {len &bytes}
//   ft1(dup) & 0x3F // {&cbytes len}
//   swp inc() // {len &bytes}
//   ret;

// /*(*/  SFN )  panic E_unclosed // prevent unclosed parens

$c_dictDump
