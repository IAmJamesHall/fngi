\ Fngi: bootstraps the fngi language.
\ Requires: spore.sp
\
\ Note: at this stage the language is severely restricted and several
\ pieces of the language are incomplete. Any CAPITAL items like FN, IF, LOOP
\ etc do not behave in the way their lower-case counterparts will behave.
\ Refer to spor.sp for all documentation.

$c_fngi

\ Stack operators. These are /not/ PRE since they directly modify the stack.
FN swp      SMART IF() spor%SWP    ELSE $c1(SWP )   END ret;
FN drp      SMART IF() spor%DRP    ELSE $c1(DRP )   END ret;
FN ovr      SMART IF() spor%OVR    ELSE $c1(OVR )   END ret;
FN dup      SMART IF() spor%DUP    ELSE $c1(DUP )   END ret;
FN dupn     SMART IF() spor%DUPN   ELSE $c1(DUPN)   END ret;

\ Standard operators that use PRE syntax
FN dvft PRE SMART IF() spor%DVFT   ELSE $c1(DVFT)   END ret;
FN dvsr PRE SMART IF() spor%DVSR   ELSE $c1(DVSR)   END ret;
FN inc  PRE SMART IF() spor%INC    ELSE $c1(INC )   END ret;
FN inc2 PRE SMART IF() spor%INC2   ELSE $c1(INC2)   END ret;
FN inc4 PRE SMART IF() spor%INC4   ELSE $c1(INC4)   END ret;
FN dec  PRE SMART IF() spor%DEC    ELSE $c1(DEC )   END ret;
FN inv  PRE SMART IF() spor%INV    ELSE $c1(INV )   END ret;
FN neg  PRE SMART IF() spor%NEG    ELSE $c1(NEG )   END ret;
FN not  PRE SMART IF() spor%NOT    ELSE $c1(NOT )   END ret;
FN i1to4 PRE SMART IF() spor%CI1    ELSE $c1(CI1 )  END ret;
FN i2to4 PRE SMART IF() spor%CI2    ELSE $c1(CI2 )  END ret;

FN +    PRE SMART IF() spor%ADD    ELSE $c1(ADD )   END ret;
FN -    PRE SMART IF() spor%SUB    ELSE $c1(SUB )   END ret;
FN %    PRE SMART IF() spor%MOD    ELSE $c1(MOD )   END ret;
FN <<   PRE SMART IF() spor%SHL    ELSE $c1(SHL )   END ret;
FN >>   PRE SMART IF() spor%SHR    ELSE $c1(SHR )   END ret;
FN msk  PRE SMART IF() spor%MSK    ELSE $c1(MSK)    END ret;
FN jn   PRE SMART IF() spor%JN     ELSE $c1(JN  )   END ret;
FN xor  PRE SMART IF() spor%XOR    ELSE $c1(XOR )   END ret;
FN and  PRE SMART IF() spor%AND    ELSE $c1(AND)    END ret;
FN or   PRE SMART IF() spor%OR     ELSE $c1(OR  )   END ret;
FN ==   PRE SMART IF() spor%EQ     ELSE $c1(EQ  )   END ret;
FN !=   PRE SMART IF() spor%NEQ    ELSE $c1(NEQ )   END ret;
FN >=   PRE SMART IF() spor%GE_U   ELSE $c1(GE_U)   END ret;
FN <    PRE SMART IF() spor%LT_U   ELSE $c1(LT_U)   END ret;
FN *    PRE SMART IF() spor%MUL    ELSE $c1(MUL )   END ret;
FN /    PRE SMART IF() spor%DIV_U  ELSE $c1(DIV_U ) END ret;

FN xsw  PRE SMART assertNoInstant(_) $c1(SZA+XSW) ret;
FN xw   PRE SMART assertNoInstant(_) $c1(SZA+XW)  ret;


\ memSet: {dst v len}   "dst = v"
\ memMove {dst src len} "dst = src"
\ memCmp: {&a &b len -> cmp}
FN memSet  PRE SMART IF() dvft(D_memSet) ELSE lit(D_memSet) $c1(DVFT) END ret;
FN memMove PRE SMART IF() dvsr(D_memSet) ELSE lit(D_memSet) $c1(DVSR) END ret;
FN memCmp  PRE SMART IF() dvft(D_memCmp) ELSE lit(D_memCmp) $c1(DVFT) END ret;
FN memClear PRE  0 swp; ret memSet(_, _) \ {addr len} clear memory

\ {a b} return if a < b
FN retlt PRE SMART assertNoInstant(_) $c1(GE_U) $c1(RETZ) ret;

\ ftN(addr): fetch a value of sz N from address.
FN ft1    PRE SMART IF() spor$(.1%FT) ELSE $c1(SZ1+FT) END ret;
FN ft2    PRE SMART IF() spor$(.2%FT) ELSE $c1(SZ2+FT) END ret;
FN ft4    PRE SMART IF() spor$(.4%FT) ELSE $c1(SZ4+FT) END ret;

\ srN(value, addr): store a value of sz N to address.
FN sr1    PRE SMART IF() spor$(.1%SR) ELSE $c1(SZ1+SR) END ret;
FN sr2    PRE SMART IF() spor$(.2%SR) ELSE $c1(SZ2+SR) END ret;
FN sr4    PRE SMART IF() spor$(.4%SR) ELSE $c1(SZ4+SR) END ret;

FN = SMART drp panic(E_cToken)    \ prevent hanging =
FN ) SMART drp panic(E_cUnclosed) \ prevent hanging )
FN setSysLogLvl PRE _SET sysLogLvl ret; \ {logLvl}
FN setUsrLogLvl PRE _SET usrLogLvl ret; \ {logLvl}

\ TODO: alias?
$(select(REF sr2, REF sr4, ASIZE == 2) -> dictSet srA)
$(select(REF sr2, REF sr4, ASIZE == 2) -> dictSet ftA)
$(TY_FN_PRE + TY_FN_SMART -> c_makeFn srA)
$(TY_FN_PRE + TY_FN_SMART -> c_makeFn ftA)

FN strEq PRE \ {aLen &a bLen &b}
  $declVar(declL bLen, TY_VAR_INPUT+SZA, ASIZE)
  $declVar(declL b, TY_VAR_INPUT+SZA, ASIZE)
  $declEnd
  swp \ {&a aLen}
  IF(\aLen != GET bLen)  drp; ret FALSE;  END \ {&a}
  ret(memCmp(\a, GET b, GET bLen) == 0)

FN zEq PRE \ {&aZ &bZ} compare two zoab strings
  $declVar(declL bZ, TY_VAR_INPUT+SZA, ASIZE) $declEnd
         ft1(dup) -> swp -> inc; \ {aLen &a}
  GET bZ ft1(dup) -> swp -> inc; \ {aLen &a bLen &b}
  -> ret strEq;

$loc TOKEN_COMMA  |,|
$loc TOKEN_SEMI   |;|
$loc TOKEN_ARROW  |->|
FN c_isComment \ [ -> bool] return true if token is a comment
  TRUE -> retif(ft1(GET c_tokenBuf) == 0c\\)
          retif(zEq(REF c_tokenLen, TOKEN_COMMA))
          retif(zEq(REF c_tokenLen, TOKEN_SEMI))
          retif(zEq(REF c_tokenLen, TOKEN_ARROW))
  drp; ret(FALSE)

FN skipComments \ skip any comments in tokens.
  LOOP l0  retif(ft1(GET c_tokenBuf) != 0c\\)
    c_single(FALSE); c_scanNoEof;  AGAIN l0

FN eqToken PRE \ [&zStr -> bool]
  skipComments;
  ft1(dup); swp; inc(\zStr) \ {expectLen &expect}
  ret strEq(\(expectLen, &expect), GET c_tokenLen, GET c_tokenBuf)
FN assertToken PRE \(&zStr) eqToken(_), E_cNeedToken -> $jmpl assert

$loc TOKEN_EQ |=|
FN CONST  SMART assertNoInstant(_) \ CONST <name> = <value>
  c_updateRKey; loc; \ {&key}: update c_rKey and initialize dict@name
  c_scan; assertToken(TOKEN_EQ) \ {&key}: expect "="
  c_instant; \ compile next token as instant (like it was $)
  swp; ret sr4(\num, \(&key));

FN between PRE \ {value a b -> bool} value is between [a b)
  $declVar(declL b, TY_VAR_INPUT+SZA, ASIZE) $declEnd \ {value a}
  ovr; swp; \ {value value a}
  IF(\value < \a)  drp; ret FALSE;  END
  ret(\value < GET b);

FN elif unreach;  FN else unreach;

$loc TOKEN_DO |do|
$loc TOKEN_ELIF |elif|
$loc TOKEN_ELSE |else|

\ Note: if mapping. We use recursion to store h.
\ if <token>   do <token>  ->  IF <token>       <token>
\ elif <token> do <token>  ->  ELSE <token> IF  <token>
\ else            <token>  ->  ELSE             <token>
\                              END END END
FN _if \ [] recursive function of `if`
  $declVar(declL h, SZA, ASIZE) $declEnd
  c_single(c_scan; FALSE) \ compile token after if
  0 -> $xsl IF -> _SET h
  assertToken(c_scan; TOKEN_DO) c_single(c_scan; FALSE) \ do <token>
  c_scan;
  IF(eqToken(TOKEN_ELIF))       GET h, 0 -> $xsl ELSE -> _SET h;  _if;
  ELSE IF(eqToken(TOKEN_ELSE))
    GET h, 0 -> $xsl ELSE -> _SET h;  c_single(c_scan; FALSE)
  ELSE  0 -> _SET c_tokenLen \ else: only peek
  END END  ret _END(GET h)

\ if <token> do <token>  elif <token> do <token>  else <token>
FN if SMART assertNoInstant(_); ret _if();

$loc TOKEN_BRK_O |[|
$loc TOKEN_BRK_C |]|
FN ufn SMART \ ufn <token> [ <inputs> -> <locals> ] do ( <code> )
  assertNoInstant(_)
  0 -> $xsl FN \ declare function
  c_scan;

