// Fngi bootstrap script: this script bootstraps the fngi language.
// Requires: spore.sp
//
// Note: at this stage the language is severely restricted and several
// pieces of the language are incomplete. Any CAPITAL items like FN, IF, LOOP
// etc do not behave in the way their lower-case counterparts will behave.
// Refer to spor.sp for all documentation.

$c_fngi

// Stack operators. These are /not/ PRE since they directly modify the stack.
SFN swp      SMART IF() spor%SWP    ELSE $c1(SWP )   END ret;
SFN drp      SMART IF() spor%DRP    ELSE $c1(DRP )   END ret;
SFN ovr      SMART IF() spor%OVR    ELSE $c1(OVR )   END ret;
SFN dup      SMART IF() spor%DUP    ELSE $c1(DUP )   END ret;
SFN dupn     SMART IF() spor%DUPN   ELSE $c1(DUPN)   END ret;

// Standard operators that use PRE syntax
SFN dvft PRE SMART IF() spor%DVFT   ELSE $c1(DVFT)   END ret;
SFN dvsr PRE SMART IF() spor%DVSR   ELSE $c1(DVSR)   END ret;
SFN inc  PRE SMART IF() spor%INC    ELSE $c1(INC )   END ret;
SFN inc2 PRE SMART IF() spor%INC2   ELSE $c1(INC2)   END ret;
SFN inc4 PRE SMART IF() spor%INC4   ELSE $c1(INC4)   END ret;
SFN dec  PRE SMART IF() spor%DEC    ELSE $c1(DEC )   END ret;
SFN inv  PRE SMART IF() spor%INV    ELSE $c1(INV )   END ret;
SFN neg  PRE SMART IF() spor%NEG    ELSE $c1(NEG )   END ret;
SFN not  PRE SMART IF() spor%NOT    ELSE $c1(NOT )   END ret;
SFN i1to4 PRE SMART IF() spor%CI1    ELSE $c1(CI1 )   END ret;
SFN i2to4 PRE SMART IF() spor%CI2    ELSE $c1(CI2 )   END ret;

SFN +    PRE SMART IF() spor%ADD    ELSE $c1(ADD )   END ret;
SFN -    PRE SMART IF() spor%SUB    ELSE $c1(SUB )   END ret;
SFN %    PRE SMART IF() spor%MOD    ELSE $c1(MOD )   END ret;
SFN <<   PRE SMART IF() spor%SHL    ELSE $c1(SHL )   END ret;
SFN >>   PRE SMART IF() spor%SHR    ELSE $c1(SHR )   END ret;
SFN bAnd PRE SMART IF() spor%BAND   ELSE $c1(BAND)   END ret;
SFN bOr  PRE SMART IF() spor%BOR    ELSE $c1(BOR )   END ret;
SFN xor  PRE SMART IF() spor%XOR    ELSE $c1(XOR )   END ret;
SFN lAnd PRE SMART IF() spor%LAND   ELSE $c1(LAND)   END ret;
SFN lOr  PRE SMART IF() spor%LOR    ELSE $c1(LOR )   END ret;
SFN ==   PRE SMART IF() spor%EQ     ELSE $c1(EQ  )   END ret;
SFN !=   PRE SMART IF() spor%NEQ    ELSE $c1(NEQ )   END ret;
SFN >=   PRE SMART IF() spor%GE_U   ELSE $c1(GE_U)   END ret;
SFN <    PRE SMART IF() spor%LT_U   ELSE $c1(LT_U)   END ret;
SFN *    PRE SMART IF() spor%MUL    ELSE $c1(MUL )   END ret;
SFN /    PRE SMART IF() spor%DIV_U  ELSE $c1(DIV_U ) END ret;

SFN xsw  PRE SMART assertNoInstant $c1(SZA+XSW) ret;
SFN xw   PRE SMART assertNoInstant $c1(SZA+XW)  ret;

// ftN(addr): fetch a value of sz N from address.
SFN ft1    PRE SMART IF() spor$(.1%FT) ELSE $c1(SZ1+FT) END ret;
SFN ft2    PRE SMART IF() spor$(.2%FT) ELSE $c1(SZ2+FT) END ret;
SFN ft4    PRE SMART IF() spor$(.4%FT) ELSE $c1(SZ4+FT) END ret;

// srN(value, addr): store a value of sz N to address.
SFN sr1    PRE SMART IF() spor$(.1%SR) ELSE $c1(SZ1+SR) END ret;
SFN sr2    PRE SMART IF() spor$(.2%SR) ELSE $c1(SZ2+SR) END ret;
SFN sr4    PRE SMART IF() spor$(.4%SR) ELSE $c1(SZ4+SR) END ret;

SFN = SMART drp panic(E_cToken) // prevent hanging =
SFN ) SMART drp panic(E_cUnclosed) // prevent unclosed parens
SFN setSysLogLvl PRE _SET sysLogLvl ret; // {logLvl}
SFN setUsrLogLvl PRE _SET usrLogLvl ret; // {logLvl}
SFN memCmp   PRE  ret dvft(D_memCmp) // {&a &b len -> cmp}
SFN memSet   PRE  ret dvft(D_memSet) // {dst v len}   "dst = v"
SFN memMove  PRE  ret dvsr(D_memSet) // {dst src len} "dst = src"
SFN memClear PRE  0 swp; $jmpl memSet; // {dst len}

SFN c_shiftBuf // shift buffer to clear current token
  (GET c_tokenBuf, dup + GET c_tokenLen, GET c_tokenLen)
  $jmpl memMove

// FN_REF <function>: &fn (as literal or instant)
SFN FN_REF   SMART
  dictGetR; assertTyped(dup) // {asInst &metaRef}
  ft4(_)    assertFn(dup)    // {asInst metaRef}
  toRef(_)  swp              // {&fn asInst}
  ret(IF(_) _ ELSE lit(_) END)

FN strEq PRE // {aLen &a bLen &b}
  // $SZ2 INPUT aLen $SZ4 INPUT a
  $SZ2 INPUT bLen  $SZ4 INPUT b END_LOCALS
  swp // {&a aLen}
  IF(_ != GET bLen)  drp; ret FALSE;  END // {&a}
  ret(memCmp(_, GET b, GET bLen) == 0)

SFN assertToken PRE // {zStr}
  ft1(dup) swp; inc(_) // {expectLen &expect}
  strEq(_, _, GET c_tokenLen, GET c_tokenBuf)
  (_, E_cNeedToken) $jmpl assert

$loc TOKEN_EQ | =|

SFN CONST  SMART assertNoInstant // CONST <name> = <value>
  c_updateRKey; loc; // {&key}: update c_rKey and initialize dict@name
  c_scan; assertToken(TOKEN_EQ) // {&key}: expect "="
  assert(c_number, E_cNeedNumber); // {&key num}
  swp; ret sr4(_, _);

FN SET  SMART // SET <name> = <value>
  $SZ4 LOCAL rMetaRef  $SZ1 LOCAL isFromLocal END_LOCALS
  assertNoInstant;
  c_scan; anyDictGetR;  _SET isFromLocal  _SET rMetaRef // cache <name>
  c_scan; assertToken(TOKEN_EQ) // "SET name ="
  xw(GET c_compFn) // <value>
  ret _setImpl(GET rMetaRef, GET isFromLocal)

FN gheapReserve PRE  $SZ2 INPUT len END_LOCALS
  memSet(GET c_gheap, 0, GET len) // clear bytes
  SET c_gheap = (GET c_gheap + GET len);
  ret;

FN /*  // block-comment */
  $SZ1 LOCAL lastTy // 0=*, 1=/  2=other
  $SZ1 LOCAL c
  END_LOCALS SMART drp; // ignore asInstant
  SET lastTy = 2; // other
  LOOP l0
    IF(GET c_tokenLen >= GET c_tokenSize)  c_assertNoEof(c_readNew)  END
    GET c_tokenLen; // {c_tokenLen}
    SET c = ft1(dup + GET c_tokenBuf); // {c_tokenLen}
    SET c_tokenLen = inc(_); // increment c_tokenLen

    IF(0c/ == GET c)
      retz(GET lastTy) // Found: */ (done)
      SET lastTy = 1; // lastTy=/
    ELSE IF(0c* == GET c)
      IF(1 == GET lastTy) // Found: /*
        FALSE spor$xl /* // recursively call block-comment. */
      ELSE  SET lastTy = 0;  END
    ELSE  SET lastTy = 2;    END END
  AGAIN l0

FN between PRE // {value a b -> bool} value is between [a b)
  $SZ4 INPUT b   END_LOCALS // {value a}
  ovr; swp; // {value value a}
  IF(_ < _)  drp; ret FALSE;  END // {value}: if(value<a) do ret FALSE
  GET b; ret(_ < _); // ret(value < b)

// **********
// * Block Allocator (BA)
// The Block Allocator (BA) is used to allocate and free 4KiB blocks. It can
// store up to 255 of them (almost a full MiB).
//
// It's implementation architecture is built on the Byte Singly Linked List
// (BSLL). The structure of a BSLL is an array of bytes, up to length 255.
// Each byte can contain either 0xFF (BA_iNull) or the index of the next node.
// At initialization, the root points to the first index and each index
// points to the next index. Allocation is then simply popping indexes
// from the SLL.
//
// STRUCT BA [ // size=10
//   indexes: &U1;   // 0: pointer to indexes (up to 255 bytes)
//   blocks: APtr;   // 4: pointer to data blocks, each of 4KiB
//   len: U1;        // 5: number of indexes and blocks
//   root: U1;       // 6: root free block, may be 0xFF if empty
// ]

CONST NULL = 0;
CONST BA_iNull = 0xFF;
CONST BA_blockPo2 = 12;  // 4KiB == 2^12
CONST BA_halfBlock = 2048;

// STRUCT BA
//    BA_indexesOfs = 0;  // indexes: APtr
CONST BA_blocksOfs  = 4;  // blocks: APtr
CONST BA_lenOfs     = 9;  // len: U1
CONST BA_rootOfs    = 10; // root: U1

SFN BA_iToPtr PRE // {bi &ba -> &block}
  ft4(_ + BA_blocksOfs); swp;            // {&firstBlock bi}
  IF(dup == BA_iNull) drp; ret NULL; END // {&firstBlock bi}
  ret(_ + (_ << BA_blockPo2))

FN BA_ptrToI PRE // {&block &ba -> bi}
  $SZ4 INPUT block  $SZ4 INPUT ba  END_LOCALS
  IF(not GET block)  ret BA_iNull;  END
  assert(
    between( // block between [&firstBlock, &lastBlockEnd)
      GET block,
      ft4(GET ba + BA_blocksOfs), // {&firstBlock}
      dup + (inc(ft1(GET ba + BA_lenOfs)) << BA_blockPo2),
    ), E_iBlock)
  ret(GET block - ft4(GET ba + BA_blocksOfs));

SFN BA_iGet  PRE ret ft1(_ + ft4(_)) // {bi &ba -> bi}
SFN BA_iSet  PRE  // {value bi &ba}  set ba@bi = value
  _ + ft4(_) // {value &index}
  ret sr1(_, _)

FN BA_init PRE // {&ba}
  $SZ4 INPUT ba  $SZ1 LOCAL iLast  END_LOCALS
  SET iLast = dec(ft1(GET ba + BA_lenOfs));
  sr1(0, GET ba + BA_rootOfs); // initialze root as index=0
  0 LOOP l0 // {bi}
    IF(dup == GET iLast)
      BA_iNull; swp; // {BA_iNull bi}
      ret BA_iSet(_, _, GET ba)
    END // {bi}
    dup; inc(_); ovr; // {bi bi+1 bi}
    BA_iSet(_, _, GET ba)
    inc(_) // {bi+1}
  AGAIN l0

// $setSysLogLvl(LOG_EXECUTE)
$BA_init(REF BA_kernel)

// { &ba -> bi} alocate a block index
// (returning a) root->a->b ===> root->b
FN BA_iAlloc PRE
  $SZ4 INPUT ba  END_LOCALS
  ft1(GET ba + BA_rootOfs) // {biRoot}
  reteq(dup, BA_iNull) // {biRoot} return BA_iNull if biRoot=BA_iNull
  sr1(BA_iGet(dup, GET ba), GET ba + BA_rootOfs); // {biRoot} root=next node
  ret _;

// {bi &ba} free a block index
// (freeing bi=a) root->b  ===>  root->a->b
FN BA_iFree PRE
  $SZ1 INPUT bi  $SZ1 LOCAL biRoot  $SZ4 INPUT ba  END_LOCALS
  assert(BA_iNull != GET bi, E_iBlock)
  SET biRoot = ft1(GET ba + BA_rootOfs)
  BA_iSet(GET biRoot, GET bi, GET ba)  // a -> b  (note: may be BA_iNull)
  ret sr1(GET bi, GET ba + BA_rootOfs) // root -> a

SFN BA_alloc PRE ret BA_iToPtr(BA_iAlloc(_)); // {&ba -> &blockNullable}
SFN BA_free  PRE // {&block &ba}
  swp; ovr; // {&ba &block &ba}
  BA_ptrToI(_); swp; // {bi &ba}
  ret BA_iFree(_, _);

// **********
// * Singly Linked List (SLL)
// Singly linked lists are used throughout fngi because of their simplicity
// and extensibility. A singly linked list is a data structure that looks like
// below, with how the operations affect it as well.
//
// start    : root -> b -> NULL
// push a   : root -> a -> b -> NULL
// now pop a: root -> b -> NULL (return a)
//
// STRUCT SLL [ next: &SLL ]
// Note: root is just a pointer to a SLL with no data (&SLL)

FN SLL_pop  PRE // {&root -> &a}: Pop a node from the SLL
  $SZ4 INPUT root  END_LOCALS
  ft4(GET root); // {&a}
  retz(dup); // {&a}
  ret sr4(ft4(dup), GET root); // {&a} root->b

FN SLL_push PRE // {&a &root}: Push a node onto the SLL
  $SZ4 INPUT a  $SZ4 INPUT root  END_LOCALS
  IF(not ft4(GET root))  sr4(NULL, GET a); // a->NULL
  ELSE                   sr4(GET root, GET a);  END // a->b
  ret sr4(GET a, GET root); // root->a

// **********
// * Arena Allocator (AA)
// The arena budy allocator is built on top of the BA. It allows allocations of
// power of 2 blocks of sizes 2^2 (4 bytes) to 2^12 (4KiB).
//
// The AA keeps track of blocks it owns by using the BA's indexes (the same way
// the BA keeps track of free blocks). When the arena is dropped, all (4KiB)
// blocks are returned to the BA.
//
// The AA does a best-effort job of trying to join freed blocks to prevent
// fragmentation. However, it prioritizes known speed over reduction of
// fragmentation. It's performance requires a maximum of 12 loops for any
// request, except for freeing blocks which can require a BA index scan (rare).
//
// If further fragmenetation reduction is required, a library can implement methods
// to sort the freed areas and join conjoining ones. However the proper method to
// eliminate fragmentation is to move any still-needed data to a new arena and
// drop the fragmented one (obviously requiring careful programming).
//
// ## Design:
// The allocator has an array of pointers, each pointing to a larger po2.
// Multiple free blocks in a single power of 2 are stored by creating a
// singly-linked-list in the first 4 bytes of the free memory. Any freed (4KiB)
// blocks are returned to the BA.
//
// STRUCT AA [
//   bi: U1;  // block index for allocated block.
//   _reserved1: U1;
//   _reserved2: U2;
//   ba: &BA;
//   // Po2 2 - 11 Clever: &aa@2 is the 0th index (2nd power), &aa@11 is 11th
//   roots: arr[10; APtr];
// ]

CONST AA_size     = 48;
CONST AA_baOfs    = 4;
CONST AA_rootsOfs = 8;

SFN AA_validPo2 PRE ret between(_, 2, 12); // {po2 -> bool}
SFN AA_assertPo2 PRE (AA_validPo2(_), E_aaPo2)$jmpl assert // {po2 [2,11]

FN AA_init // {&ba &aa}
  $SZ4 INPUT aa  END_LOCALS
  GET aa + AA_baOfs;  sr4(_, _); // set ba
  (GET aa + AA_rootsOfs, 10 << 2) $jmpl memClear // all roots=NULL

FN AA_allocPo2 PRE // {po2 &aa -> &free}
  $SZ1 INPUT po2  $SZ1 LOCAL gotPo2  $SZ4 INPUT aa  END_LOCALS
  AA_assertPo2(GET po2);
  SET gotPo2 = GET po2;
  LOOP l0  // Find a free block of the appropriate size
    BREAK_EQ (12, GET gotPo2)                   b0
    BREAK_IF (ft4(GET aa + (GET gotPo2 << 2)))  b1
    SET gotPo2 = inc(GET gotPo2);
  AGAIN l0  END_BREAK b0  END_BREAK b1
  LOOP l1 // Break the block until it is the right size.
    // Get pointer to the free memory.
    IF(GET gotPo2 == 12)  BA_alloc(GET aa + AA_baOfs); // {&free}
    ELSE SLL_pop(GET aa + (GET gotPo2 << 2))  END      // {&free}
    reteq(GET po2, GET gotPo2) // {&free}: return if correct po2
    SET gotPo2 = dec GET gotPo2; // {&free}: reduce gotPo2 since we're spliting in half
    // The next cycle will return or divide one of the free blocks.
    SLL_push(dup,                   GET aa + (GET gotPo2 << 2))
    SLL_push(_ + (1 << GET gotPo2), GET aa + (GET gotPo2 << 2))
  AGAIN l1

FN AA_freePo2 PRE // {&free po2 &aa}
  $SZ1 INPUT po2  $SZ1 LOCAL gotPo2  $SZ4 INPUT aa  END_LOCALS // {&free}
  AA_assertPo2(GET po2);

$c_dictDump
