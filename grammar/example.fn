// Some valid expresssions
{};
1;
0x100;
1 + 2;
1 + 2 * 3;
100 - 2 / 5;
x := 10;
3 > 7;
3 >= 7;
3 <= 7;
3 < 7;
x bitor 999;
z bitand 999;
x and y;
d or z;

foo$ {};
foo$ 3;
foo$ {3; 7};
foo$ {x=3; y=7};
foo$ {
  x=3;
  y=7;
};

"foo";
"foo" + " bar";
1 * (2 + 3);
x + 3 >= z$ 3 and j bitor 0x100 != FLAG;


// x: U32 = 42;

// let world: Str = "World \n";
// 
// fn plus3: U32 -> U32 (
//   inp + 3  // inp is reserved name, means "input"
// );
// 
// let x: U32 = 7;
// let refX: &U32 = &x;
// let derefRefX: U32 = @refX;
// 
// // Some example usage:
// // stk[U32, I32, I8]
// // [3 U32]
// // [3 [7 U32]]
// // let a: [3 U32] = {42, 900, 0};
// // let p: Point = {x=10; y=77};
// 
// fn plus3Param: [x: U32] -> U32 (
//   inp.x + 3
// );
// 
// fn isEqual3: I32 -> Bool (
//   if inp == 3 then true
//   elif inp == -666 then !panic "devil"
//   else false
// );
// 
// fn plus3Times7: U32 -> U32 (
//   // Equivalent: (inp + 3) * 7
//   // Using function to demo function calls
//   plus3$ inp * 7
// );
// 
// fn letBlock: [] -> U32 (
//   let x: U32 = (4 + 7 * 3);
//   x
// );
// 
// fn helloWorld: [] -> [] (
//   // !writeln "Hello World";
//   // !writeln ("Hello " + World");
// );
// 
// fn stkPlus3: stk[U32] -> stk[U32] (
//   popU32$[] + 3
// );
// 
// struct Point: [
//   x: I32;
//   y: I32;
// ];
// 
// impl Point: [] (
//   fn distance: [self: &Point; other: &Point] -> U32 (
//     sqrt[U32]$ (
//       po2[U32]$(self.x - other.x)
//       + po2[U32]$(self.y - other.y)
//     )
//   );
// );
// 
// 
// !gen (
//   struct Vec[V]: [
//     cap: U16;
//     len: U16;
//     data: Ptr;
//   ];
// 
//   impl Vec[V]: [] (
//     fn get: [self: Vec[V]; index: U16] -> V (
//       // let ref: &V = asRef(self.data + index * sizeOf(U32));
//       // @ref
//     )
// 
//     // etc
//   );
// );
