// Some valid expresssions
{};
1;
0x100;
1 + 2;
1 + 2 * 3;
100 - 2 / 5;
x := 10;
3 > 7;
3 >= 7;
3 <= 7;
3 < 7;
x bitor 999;
z bitand 999;
x and y;
d or z;
-7;
&-7;
not 0;
{3; 7};
{x=3; y=7};
arr{3; 4; 5};
stk{0; 42; 77;};

foo$ {};
foo$ 3;
foo$ {3; 7};
foo$ {x=3; y=7};
foo$ {
  x=3;
  y=7;
};
x.y.z;
inp.0;
X[T; Y];
X[T; A[B[C; D]]];
a[foo].X[S; T].0;
X[T; Y]$ 3;
X[T; Y].foo$ {3; 7};
x.y.z + 99 / x.y.a;
X[4 &T; Z];

"foo";
"foo" + " bar";
1 * (2 + 3);
x + 3 >= z$ 3 and j bitor 0x100 != FLAG;
(
  x + 8;
  y := 98;
  y
);

x[a].y! 8;
z[b].k!! a.b {42; 33};
x[a].y! 8 $ 42;
z[b].k!! a.b {42; 33} $ 42;


// Valid Expressions and Statements
if true do foo${};

if x == 7: U32 do 7 eldo 22;

if x == 7: U32 do 7
elif x == -7 do -77
eldo 22;

if x == 7: U32 do (
  if x == 10: U32 do x
  eldo y
) eldo z;

if x == 7: U32 do
  if x == 10: U32 do x
  eldo y
eldo z;

while x <= 7 do (
  x := x + 3;
);

while x <= 7: U32 do (
  x := x + 3
) eldo -77;

break 42;

while x <= 7: U32 do (
  x := x + 3;
  if x >= 8 do break 42;
) eldo -77;

// Valid Statements
x: U32 = 42;

world: Str = "World \n";
myFn: U32 -> U32 = bob;

fn returnEmpty: [] -> [] do {};
fn return3: [] -> U32 do 3;

fn plus3: U32 -> U32 do (
  inp + 3  // inp is reserved name, means "input"
);

x: U32 = 7;
refX: &U32 = &x;
derefRefX: U32 = @refX;

fn plus3Param: [x: U32] -> U32 do x + 3;

fn isEqual3: I32 -> Bool do (
  if inp == 3 do true
  elif inp == -666 do panic! "devil"
  eldo false
);

fn plus3Times7: U32 -> U32 do (
  // Equivalent: (inp + 3) * 7
  // Using function to demo function calls
  plus3$ inp * 7
);

fn useVar: [] -> U32 do (
  x: U32 = (4 + 7 * 3);
  x
);

fn helloWorld: [] -> [] do (
  // println! "Hello World";
  println! ("Hello " + "World");
);

fn stkPlus3: stk[U32] -> stk[U32] do (
  popU32${} + 3;
  pushU32${}
);

struct Point: [
  x: I32;
  y: I32;
];

impl Point: [] (
  x: U32 = 32;

  fn distance: [self: &Point; other: &Point] -> U32 do (
    sqrt[U32]$(
      po2[U32]$(self.x - other.x)
      + po2[U32]$(self.y - other.y)
    )
  );
);


// !gen (
//   struct Vec[V]: [
//     cap: U16;
//     len: U16;
//     data: Ptr;
//   ];
// 
//   impl Vec[V]: [] (
//     fn get: [self: Vec[V]; index: U16] -> V (
//       // ref: &V = asRef(self.data + index * sizeOf(U32));
//       // @ref
//     )
// 
//     // etc
//   );
// );


fn nestedLabels: [] -> [] do (
  #first
  v: U32 = while x: U32 do (
    #second while y do (
      x := x + 3;
      if x == y do cont #first
      elif x == 42 do break #first 442;
    )
  ) eldo -77;

  v
);
