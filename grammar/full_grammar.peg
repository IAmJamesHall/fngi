# A file is a list of let statements
file = ( (ws / comment / let) ws? ";"? )*

# Lexemes
ws = ~"\\s+"          # whitespace is ignored
numeric = ~"[0-9]"    # note: ~"..." is a regex
alpha  = ~"[A-Z]"i    # note: i means "ignore case"
alphanumeric = ~"[0-9A-Z]"i
never = ws? "[" "]"  # never/void type and value
rawStr = ws? ~'"[^"]"'s               # "this is a raw string"
escapedStr = ws? ~'(?s)\\\".*?\\\"'s  # \"this is an escaped string\"


# Comments
comment = lineComment / blockComment
lineComment = ws? ~"//.*\n"       # // a line comment
blockComment = ws? ~"/\\*.*?\\*/"s  # /* a block comment */


number = ws? numeric+
iden   = ws? alpha alphanumeric*
op =  (  # binary operator
  "$"
  / "==" / "!=" / "and" / "or"
  / "bitand" / "bitor" / "bitxor"
  / "+" / "-" / "*" / "/"
)

unaryOp = (
  "&" / "@" / "not" / "-"
)


# Blocks, expressions and statements
expr = exprUnit ( ws? op exprUnit )*
block = ws? "(" stmt* expr? ws? ")"
stmt = ( let / expr ) ws? ";"

let = ws? "let" iden ws? ":" type ws? "=" expr
exprUnit = ws? unaryOp? ( value / name / block )


# Names: A macro call can be anywhere a name can appear
# Macros are the only prefix operators because they
# must be parsed in the expression. Normally they
# are part of the name, i.e. `!foo` instead of `! foo`
name = macro1 / macro2 / nameNoMacro

macro1 = ws? "!" nameNoMacro expr
macro2 = ws? "!!" nameNoMacro expr expr

# A non-macro name is composed of name units chained by "."
nameNoMacro = nameUnit (ws? "." nameUnit)*
nameUnit = ws? iden nameBlock?
nameBlock = (
  ws? "[" 
    number? ws? "&"? name 
    (ws? ";" number? ws? "&"? name)* ws? ";"? ws? 
  "]")


# Types
type = ws? "&"? ( typeFn / typeNoFn )
typeFn = typeNoFn ws? "->" typeNoFn
typeNoFn = ws? (
  never / stack / array
  / structTyBlock / paramsTyBlock
  / name
)

idenType = iden ws? ":" type
structTyBlock = ws? "[" idenType (ws? ";" idenType)* ws? ";"? ws? "]"
paramsTyBlock = ws? "[" idenType (ws? "," idenType)* ws? ","? ws? "]"

stack = ws? "stk" ws? "[" type (ws? "," type)* ws? ","? ws? "]"
array = ws? "[" number type ws? "]"

# Values
value = ws? (
  never / number / rawStr / escapedStr
  / structValue / paramsValue
)

idenEq = iden ws? "=" expr
structValue = ws? "{" idenEq ( ws? ";" idenEq )* ws? ";"? ws? "}"
paramsValue = ws? "{" expr ( ws? "," expr )* ws? ","? ws? "}"
