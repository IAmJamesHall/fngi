file = (stmt SC)* w?

# Lexemes
w = (whitespace / lineComment / blockComment)+
whitespace = ~"\\s+"          # whitespace is ignored
lineComment = ~"//.*\n"         # // a line comment
blockComment = ~"/\\*.*?\\*/"s  # /* a block comment */

C = w? ":" # colon
SC = w? ";" # semi-colon
VOID = "[" w? "]"
EMPTY = "{" w? "}"
NUMBER = ("0x" _hex+) / _numeric+
IDEN = _alphanumeric+
STR = _escStr / _rawStr
FN = "fn"
STRUCT = "struct"
STK = "stk"
ARR = "arr"
NOT = "not"
AND = "and"
OR = "or"
BITNOT = "bitnot"
BITOR = "bitor"
BITXOR = "bitxor"
BITAND = "bitand"


# Helper Regexes
_numeric = ~"[0-9]"    # note: ~"..." is a regex
_hex = ~"[0-9A-F]"i
_alpha  = ~"[A-Z]"i    # note: i means "ignore case"
_alphanumeric = ~"[0-9A-Z]"i
_escStr = ~'(?s)\\\".*?\\\"'s  # \"this is a\n"escaped" string\"
_rawStr = ~'"[^"]"'s           #  "this is a raw string"


# Statement Selection
stmt = expr


# Expression Recursive Descent
expr = assign
assign = equality (w? ":=" equality)*
equality = logical (w? ( "!=" / "==" ) logical )*
logical = comparison (w? (OR / AND) comparison)*
comparison = bitwise (w? ( ">=" / "<=" / ">" / "<" ) bitwise )*
bitwise = term (w? (BITOR / BITXOR / BITAND) term)*
term = factor (w? ( "-" / "+" ) factor)*
factor = call (w? ( "/" / "*" ) unary)*
call = unary (w? "$" unary)*
unary = primary / (w? (BITNOT / NOT / "-" ) unary)
primary = w? (
  EMPTY / NUMBER / STR / block / stk / arr / struct
  / IDEN # TODO: name
)


# Primary Values (non-lexeme)
block = "(" multiExpr w? ")"
stk = STK w? "{" multiExpr w? "}"
arr = ARR w? "{" multiExpr w? "}"
struct = "{" (multiStructAssign / multiExpr) w? "}"
multiExpr = expr (SC expr)* SC?
multiStructAssign = structAssign (SC structAssign)* SC?
structAssign = w? IDEN w? "=" assign


# Name Recursive Descent
name = macro2
macro2 = macro1 (w? "!!" primary primary)?
macro1 = nameLiteral (w? "!" primary)?
nameLiteral = w? IDEN (w? nameBlock)? (w? "." nameLiteral)*

nameBlock = "[" nameUnit (SC nameUnit)* SC? w? "]"
nameUnit = w? NUMBER? w? "&"? name
