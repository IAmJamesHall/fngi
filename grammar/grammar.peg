file = (stmt SC)* w?

# Lexemes
w = (whitespace / lineComment / blockComment)+
whitespace = ~"\\s+"          # whitespace is ignored
lineComment = ~"//.*\n"         # // a line comment
blockComment = ~"/\\*.*?\\*/"s  # /* a block comment */

C = w? ":" # colon
SC = w? ";" # semi-colon
VOID = "[" w? "]"
EMPTY = "{" w? "}"
NUMBER = ("0x" _hex+) / _numeric+
IDEN = _alphanumeric+
STR = _escStr / _rawStr
FN = "fn"
DO = "do"
STRUCT = "struct"
STK = "stk"
ARR = "arr"
NOT = "not"
AND = "and"
OR = "or"
BITNOT = "bitnot"
BITOR = "bitor"
BITXOR = "bitxor"
BITAND = "bitand"

IF = "if"
ELIF = "elif"
ELDO = "eldo"
WHILE = "while"

BREAK = "break"
RETURN = "return"

# Helper Regexes
_numeric = ~"[0-9]"    # note: ~"..." is a regex
_hex = ~"[0-9A-F]"i
_alpha  = ~"[A-Z]"i    # note: i means "ignore case"
_alphanumeric = ~"[0-9A-Z]"i
_escStr = ~'(?s)\\\".*?\\\"'s  # \"this is a\n"escaped" string\"
_rawStr = ~'"[^"]"'s           #  "this is a raw string"


# Statement Selection
stmt = (flow / decl / expr)


# Expression Recursive Descent
expr = assign
assign = equality (w? ":=" equality)*
equality = logical (w? ( "!=" / "==" ) logical )*
logical = comparison (w? (OR / AND) comparison)*
comparison = bitwise (w? ( ">=" / "<=" / ">" / "<" ) bitwise )*
bitwise = term (w? (BITOR / BITXOR / BITAND) term)*
term = factor (w? ( "-" / "+" ) factor)*
factor = call (w? ( "/" / "*" ) unary)*
call = unary (w? "$" unary)*
unary = (w? (BITNOT / NOT / "-" / "&" / "@"))* macro2
macro2 = macro1 (w? "!!" name (decl / macro1))*
macro1 = name (w? "!" name)*
name = nameNoDot (w? "." nameNoDot)*
nameNoDot = primary (w? nameBlock)?
primary = w? (
  EMPTY / NUMBER / STR / block / stk / arr / struct
  / ifEldo / while
  / IDEN
)

# Primary Expressions (non-lexeme)
block = "(" multiLabelStmt w? ")" # lint: last un-SC stmt must be expr
stk = STK w? "{" multiExpr w? "}"
arr = ARR w? "{" multiExpr w? "}"
multiLabelStmt = label? stmt (SC label? stmt)* SC?
label = w? "#" IDEN
multiExpr = expr (SC expr)* SC?

struct = "{" (multiStructAssign / multiExpr) w? "}"
multiStructAssign = structAssign (SC structAssign)* SC?
structAssign = w? IDEN w? "=" assign

nameBlock = "[" nameBlUnit (SC nameBlUnit)* SC? w? "]"
nameBlUnit = w? NUMBER? w? ("&" / "@")? macro2

ifEldo = (
  IF expr (C ty)? w? DO stmt
  (w? ELIF expr w? DO stmt)*
  (w? ELDO stmt)?
)

while = WHILE expr (C ty)? w? DO expr (w? ELDO expr)?


# Ty Recursive Descent
ty = (w? "&")* fnTy
fnTy = primaryTy (w? "->" primaryTy)?
primaryTy = w? ( VOID / structBlock / stkBlock / arrBlock / macro2 )

stkBlock = STK w? "[" multiTy w? "]"
arrBlock = ARR w? "[" w? NUMBER ty w? "]"
structBlock = "[" (multiVar / multiTy) w? "]"
multiTy = ty (SC ty)* SC?
multiVar = declVar (SC declVar)* SC?


# Declaration Selection
decl = w? (declStruct / declFn / declVar)
declStruct = STRUCT w? name C ty w? structBlock
declFn = FN w? name C fnTy w? DO expr
declVar = IDEN C ty (w? "=" expr)?


# Flow Control
flow = w? (break / return)
break = BREAK expr?
return = RETURN expr?
