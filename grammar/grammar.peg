file = (stmt SC)* w?

# Lexemes
w = (whitespace / lineComment / blockComment)+
whitespace = ~"\\s+"          # whitespace is ignored
lineComment = ~"//.*\n"         # // a line comment
blockComment = ~"/\\*.*?\\*/"s  # /* a block comment */

C = w? ":" # colon
SC = w? ";" # semi-colon
VOID = "[" w? "]"
EMPTY = "{" w? "}"
EMPTY_BLOCK = "(" w? ")"
NUMBER = ("0x" _hex+) / _numeric+
IDEN = _alphanumeric+
STR = _escStr / _rawStr
FN = "fn"
DO = "do"
STRUCT = "struct"
ENUM = "enum"
IMPL = "impl"
STK = "stk"
ARR = "arr"
NOT = "not"
AND = "and"
OR = "or"
BITNOT = "bitnot"
BITOR = "bitor"
BITXOR = "bitxor"
BITAND = "bitand"

IF = "if"
ELIF = "elif"
ELDO = "eldo"
SWITCH = "switch"
CASE = "case"
WHILE = "while"

CONT = "cont" # continue
BREAK = "break"
RETURN = "return"


# Helper Regexes
_numeric = ~"[0-9]"    # note: ~"..." is a regex
_hex = ~"[0-9A-F]"i
_alpha  = ~"[A-Z]"i    # note: i means "ignore case"
_alphanumeric = ~"[0-9A-Z]"i
_escStr = ~'(?s)\\\".*?\\\"'s  # \"this is a\n"escaped" string\"
_rawStr = ~'"[^"]"'s           #  "this is a raw string"


# High Level: will be defined as fn ptrs. Everything else can be defined
# in the order listed here.
# - stmt
# - expr
# - ty
# - name
# - macro2


# Primary Expressions (non-lexeme)
label = w? "#" IDEN
multiLabelStmt = label? stmt (SC label? stmt)* SC?
multiExpr = expr (SC expr)* SC?

block = "(" multiLabelStmt w? ")" # lint: last un-SC stmt must be expr
stk = STK w? "{" multiExpr w? "}"
arr = ARR w? "{" multiExpr w? "}"

structAssign = w? IDEN w? "=" expr
multiStructAssign = structAssign (SC structAssign)* SC?
struct = "{" (multiStructAssign / multiExpr) w? "}"

ifElDo = (
  IF expr (C ty)? w? DO stmt
  (w? ELIF expr w? DO stmt)*
  (w? ELDO stmt)?
)

switch = (
  SWITCH expr (C ty)?
  (w? CASE w? IDEN w? DO stmt)*
  (w? ELDO stmt)?
)

while = WHILE expr (C ty)? w? DO expr (w? ELDO expr)?


# Declaration Selection
decl = declStruct / declEnum / declImpl / declFn /declVar
declStruct = w? STRUCT name C w? structBlock
declEnum = w? ENUM name C w? structBlock
declImpl = w? IMPL name C ty w? block
declFn = w? FN w? name C ty w? DO expr # lint: must be fnTy
declVar = w? IDEN C ty (w? "=" expr)?


# Type Blocks
multiVar = declVar (SC declVar)* SC?
multiTy = ty (SC ty)* SC?
stkBlock = STK w? "[" multiTy w? "]"
arrBlock = ARR w? "[" w? NUMBER ty w? "]"
structBlock = "[" (multiVar / multiTy) w? "]"
nameBlUnit = w? NUMBER? w? ("&" / "@")? macro2
nameBlock = "[" nameBlUnit (SC nameBlUnit)* SC? w? "]"


# Ty Recursive Descent
primaryTy = w? ( VOID / structBlock / stkBlock / arrBlock / macro2 )
fnTy = primaryTy (w? "->" primaryTy)?
ty = (w? "&")* fnTy


# Flow Control
flow = w? (cont / break / return)
cont = CONT label?
break = BREAK label? expr?
return = RETURN expr?


# Expression Recursive Descent
primary = w? (
  EMPTY / EMPTY_BLOCK
  / NUMBER / STR
  / block / stk / arr / struct
  / ifElDo / switch / while
  / IDEN
)
nameNoDot = primary (w? nameBlock)?
name = nameNoDot (w? "." nameNoDot)*
macro1 = name (w? "!" (decl / name))*
macro2 = macro1 (w? "!!" name (decl / macro1))*
unary = (w? (BITNOT / NOT / "-" / "&" / "@"))* macro2
call = unary (w? "$" unary)*
factor = call (w? ( "/" / "*" ) unary)*
term = factor (w? ( "-" / "+" ) factor)*
bitwise = term (w? (BITOR / BITXOR / BITAND) term)*
comparison = bitwise (w? ( ">=" / "<=" / ">" / "<" ) bitwise )*
logical = comparison (w? (OR / AND) comparison)*
equality = logical (w? ( "!=" / "==" ) logical )*
assign = equality (w? ":=" equality)*


# Highest Level
expr = assign
stmt = (flow / decl / expr)
