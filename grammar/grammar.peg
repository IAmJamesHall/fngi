file = (stmt SC)* w?

# Lexemes
w = (whitespace / lineComment / blockComment)+
whitespace = ~"\\s+"          # whitespace is ignored
lineComment = ~"//.*\n"         # // a line comment
blockComment = ~"/\\*.*?\\*/"s  # /* a block comment */

C = w? ":" # colon
SC = w? ";" # semi-colon
VOID = "[" w? "]"
EMPTY = "{" w? "}"
NUMBER = ("0x" _hex+) / _numeric+
IDEN = _alphanumeric+
STR = _escStr / _rawStr
FN = "fn"
DO = "do"
STRUCT = "struct"
STK = "stk"
ARR = "arr"
NOT = "not"
AND = "and"
OR = "or"
BITNOT = "bitnot"
BITOR = "bitor"
BITXOR = "bitxor"
BITAND = "bitand"

IF = "if"
ELIF = "elif"
ELSE = "else"
WHILE = "while"


# Helper Regexes
_numeric = ~"[0-9]"    # note: ~"..." is a regex
_hex = ~"[0-9A-F]"i
_alpha  = ~"[A-Z]"i    # note: i means "ignore case"
_alphanumeric = ~"[0-9A-Z]"i
_escStr = ~'(?s)\\\".*?\\\"'s  # \"this is a\n"escaped" string\"
_rawStr = ~'"[^"]"'s           #  "this is a raw string"


# Statement Selection
stmt = decl / expr


# Expression Recursive Descent
expr = assign
assign = equality (w? ":=" equality)*
equality = logical (w? ( "!=" / "==" ) logical )*
logical = comparison (w? (OR / AND) comparison)*
comparison = bitwise (w? ( ">=" / "<=" / ">" / "<" ) bitwise )*
bitwise = term (w? (BITOR / BITXOR / BITAND) term)*
term = factor (w? ( "-" / "+" ) factor)*
factor = call (w? ( "/" / "*" ) unary)*
call = unary (w? "$" unary)*
unary = (w? (BITNOT / NOT / "-" / "&" / "@") unary) / primary
primary = w? (
  EMPTY / NUMBER / STR / block / stk / arr / struct
  / ifElse / while
  / name
)


# Primary Expressions (non-lexeme)
block = "(" multiStmt w? ")" # but last un-SC stmt must be expr
stk = STK w? "{" multiExpr w? "}"
arr = ARR w? "{" multiExpr w? "}"
multiStmt = stmt (SC stmt)* SC?
multiExpr = expr (SC expr)* SC?

struct = "{" (multiStructAssign / multiExpr) w? "}"
multiStructAssign = structAssign (SC structAssign)* SC?
structAssign = w? IDEN w? "=" assign

ifElse = (
  IF expr (C ty)? w? DO expr
  (w? ELIF expr w? DO expr)*
  (w? ELSE expr)?
)
while = WHILE expr (C ty)? w? DO expr (ELSE expr)?


# Name Recursive Descent
name = macro2
macro2 = macro1 (w? "!!" primary primary)?
macro1 = nameLiteral (w? "!" primary)?
nameLiteral = w? IDEN (w? nameBlock)? (w? "." nameLiteral)*

nameBlock = "[" nameUnit (SC nameUnit)* SC? w? "]"
nameUnit = w? NUMBER? w? ("&" / "@")? name


# Ty Recursive Descent
ty = (w? "&")* fnTy
fnTy = primaryTy (w? "->" primaryTy)?
primaryTy = w? ( VOID / structBlock / stkBlock / arrBlock / name )

stkBlock = STK w? "[" multiTy w? "]"
arrBlock = ARR w? "[" w? NUMBER ty w? "]"
structBlock = "[" (multiVar / multiTy) w? "]"
multiTy = ty (SC ty)* SC?
multiVar = declVar (SC declVar)* SC?


# Declaration Selection
decl = w? (declStruct / declFn / declVar)
declStruct = STRUCT name C ty w? structBlock
declFn = FN name C fnTy w? DO expr
declVar = IDEN C ty (w? "=" expr)?



