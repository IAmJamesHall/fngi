// Note: not all of this is in the stage0 compiler. The stage0 compiler will only support:
// - comments
// - native types, refs, stacks, structs, enums and arrays
// - fn which take in and return unnamed stk types
// - local or global native types, structs and enums.
// - temporaries must be declared explicitly.
// - macros

// Simplest function, simply returns 3.
// Note: [] is the "void" type, this function takes no parameters.
let return3: fn [] -> U32 = ( 3 );

// Simple function with named input `v`
let plus3: fn [v: U32] -> U32 = ( v + 3 );

// Simple function with assignments
let plus3Times5: fn [v:U32] -> U32 = (
  let a: U32 = v + 3;
  a * 5
)

// Simple function with conditional
fn eqauls5: [v: U32] -> Bool (
  if (v == 5) then true else false
)

// Simple function with some control logic
fn mulUsingAdd: [a: U32, b: U32] -> U64 (
  local out: U64;
  if b == 0 then return 0;

  out = 0;
  while a > 0 (
    out = out + b;
  )
  out
)

// A reference and dereferencing
fn deref [ref: &U32] -> U32 (
  @ref // @ is for dereferencing "get value at"
)


// Type aliasing
type UserId: U32;
type u32Adder: &fn [U32, U32] -> [U32];
type u32Consumer: &fn [] -> [U32];


// Builtin array type: a continuous region of memory with known size
type array_len16_U32: arr[16; U32]

// Builtin stack type: for interfacing with core data stack instructions
// (fngi's intermediate representation is a stack machine)
//
// The "top" (first item to be popped) of the stack is on the left. Since
// stacks grow down, this is the lowest location in memory.
type stack_example: stk[U32, U16, U8, U64];

// A slice is a pointer to an array of data with a constant length
// with a maximum value of max!U16.
gen![T] // generic
struct Slice: [
  _al: U16; // align
  len: U16;
  ptr: Ptr;
]

// Here are how a slice might be implemented
gen![T]
impl Slice: [
  fn slotSize: [] -> [U32] ( sizeOf!T );

  // Of course, some of this can be inlined -- and is through constant folding.
  fn get: stk[/*sliceRef*/ &Slice[T], /*index*/ U32] -> stk[T] (
    refToPtr[]; // {slicePtr, index}
    swap[]; // {index, slicePtr}
    sizePo2Of! T; // {sizePo2T, index, slicePtr}
    shiftLeft[]; // (same as index^po2) {byteOffset, slicePtr}
    addU32[]; // valuePtr
    fetchU32[];
  )
]

// using enums
fn createU32SliceRaw: [ptr: Ptr, len: U16] -> Slice {
  // Note: unlike most C-like languages do not have to specify the type of the
  // struct -- type is known because this is the result of the expression.
  {
    _al = 0;
    len = len;
    ptr = ptr;
  }
}

// Enums can contain values.
enum ExampleEnum: [
  none: []; // void i.e. no value
  int: I32;
  str: Str;
  both: [int: I32, str: Str];
]

// Example simple use.
fn is3: [v: MaybeIntOrStr] -> Bool (
  switch v (
    case none then false;
    case int then int == 3;
    case str then false;
    case both then both.int == 3;
  )
)
