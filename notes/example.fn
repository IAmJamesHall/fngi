// Simplest function, simply returns 3.
// Note: [] is the "Void" type, this function takes no parameters.
fn return3: [] -> U32 do 3;

// Simple function with named input `v`
// - `$` is the function call operators. It's like `+` but when the left hand
//   side is a function instead of an int.
// - `{}` is "empty", i.e. no value. The only value that Void (`[]`) can be.
fn plus3: [v: U32] -> U32 do ( v + return3${} );

// Simple function with assignments
fn plus3Times5: [v:U32] -> U32 do (
  let a: U32 = plus3$ v;
  a * 5
)

// Simple function with ifEldo conditional
fn eqauls5: [v: U32] -> Bool do (
  if v == 5 do true eldo false
);

// Simple function with some control logic
fn mulUsingAdd: [a: U32; b: U32] -> U64 do (
  local out: U64;
  if b == 0 do return 0;

  out = 0;
  while a > 0 do (
    out = out + b;
  )
  out
)

// & is a reference, @ dereferences.
fn derefU32: [ref: &U32] -> U32 do @ref

// Type aliasing
type UserId: U32;
type u32Adder: &fn [U32; U32] -> [U32]; // function reference
type u32Consumer: &fn [] -> [U32];


// Builtin array type: a continuous region of memory with known size
type array_len16_U32: arr[16 U32]

// Builtin stack type: for interfacing with core data stack instructions
// (fngi's intermediate representation is a stack machine)
//
// The "top" (first item to be popped) of the stack is on the left. Since
// stacks grow down, this is the lowest location in memory.
type stack_example: stk[U32; U16; U8; U64];

// A slice is a pointer to an array of data with a constant length
// with a maximum value of max!U16.
gen![T] // generic
struct Slice: [
  _al: U16; // align
  len: U16;
  ptr: Ptr;
]

// Here are how a slice might be implemented
gen![T]
impl Slice: [
  fn slotSize: [] -> [U32] ( sizeOf!T );

  // Of course, some of this can be inlined -- and is through constant folding.
  fn get: stk[/*sliceRef*/ &Slice[T], /*index*/ U32] -> stk[T] (
    refToPtr[]; // {slicePtr, index}
    swap[]; // {index, slicePtr}
    sizePo2Of! T; // {sizePo2T, index, slicePtr}
    shiftLeft[]; // (same as index^po2) {byteOffset, slicePtr}
    addU32[]; // valuePtr
    fetchU32[];
  )
]

// using enums
fn createU32SliceRaw: [ptr: Ptr, len: U16] -> Slice {
  // Note: unlike most C-like languages do not have to specify the type of the
  // struct -- type is known because this is the result of the expression.
  {
    _al = 0;
    len = len;
    ptr = ptr;
  }
}

// Enums can contain values.
enum ExampleEnum: [
  none: []; // void i.e. no value
  int: I32;
  str: Str;
  both: [int: I32, str: Str];
]

// Example simple use.
fn is3: [v: MaybeIntOrStr] -> Bool (
  switch v (
    case none then false;
    case int then int == 3;
    case str then false;
    case both then both.int == 3;
  )
)
