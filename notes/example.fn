
// Simple function. Note that expression returns the value.
fn plus3: [v: U32] -> U32 (
  v + 3
)

// Simple function with conditional
fn eqauls5: [v: U32] -> Bool (
  if (v == 5) then true else false
)

// Simple function with some control logic
fn mulUsingAdd: [a: U32, b: U32] -> U64 (
  local out: U64;
  if b == 0 then return 0;

  out = 0;
  while a > 0 (
    out = out + b;
  )
  out
)

// Arrays must be expressed in type syntax
// U32 Array of size 5: [5 U32]

// Slices are generic. They can have a max length of maxValue![U16].
gen![T]
struct Slice: [
  _al: U16;  // alignment
  len: U16;
  ptr: Ptr;
]

gen![T]
impl Slice: [
  fn slotSize: [] -> [U32] ( sizeOf! T );

  fn get: [&Slice[T], U32] -> T (
    fetch[T]{self.ptr, index}
  )
]


// Vectors are also generic. They can have a max length and capacity of
// maxValue![U16]
//
// An &Vec: identical to a &Slice, except a Slice will never read the `cap`.
// Therefore a Vec can be converted directly into a Slice with zero overhead
// The sice will update when the vector updates.

gen![T]
struct Vec: [
  cap: U16;
  len: U16;
  ptr: Ptr;
]

// Type aliasing
type VecU32: Vec![U32];
type u32Adder: &fn [U32, U32] -> [U32];
type u32Consumer: &fn [] -> [U32];

// enum and using enum
enum MaybeIntOrStr: [
  none;
  int: Int;
  str: Str;
]

fn isInt: MaybeIntOrStr -> Bool (
  switch pop() (
    case none then false;
    case int then true;
    case str then false;
  )
)

// Stack functions with unnamed parameters
stack fn eqauls5: U32 -> Bool (
  if (popU32{} == 5) then true else false
)
