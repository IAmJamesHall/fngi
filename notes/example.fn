// Simplest function, simply returns 3.
// Note: [] is the "Void" type, this function takes no parameters.
fn return3: [] -> U32 do 3;

// Simple function with named input `v`
// - `$` is the function call operators. It's like `+` but when the left hand
//   side is a function instead of an int.
// - `{}` is "empty", i.e. no value. The only value that Void (`[]`) can be.
fn plus3: [v: U32] -> U32 do ( v + return3${} );

// Simple function with assignments
fn plus3Times5: [v:U32] -> U32 do (
  let a: U32 = plus3$ v;
  a * 5
)

// Simple function with ifEldo conditional
fn eqauls5: [v: U32] -> Bool do (
  if v == 5 do true eldo false
);

// Simple function with some control logic
fn mulUsingAdd: [a: U32; b: U32] -> U64 do (
  local out: U64;
  if b == 0 do return 0;

  out = 0;
  while a > 0 do (
    out = out + b;
  )
  out
)

// & is a reference, @ dereferences.
fn derefU32: [ref: &U32] -> U32 do @ref

// Type aliasing
type UserId: U32;
type u32Adder: &fn [U32; U32] -> [U32]; // function reference
type u32Consumer: &fn [] -> [U32];


// Builtin array type: a continuous region of memory with known size
type array_len16_U32: arr[16 U32];

// Builtin stack type: for interfacing with core data stack instructions
// (fngi's intermediate representation is a stack machine)
//
// The "top" (first item to be popped) of the stack is on the left. Since
// stacks grow down, this is the lowest location in memory.
type stack_example: stk[U32; U16; U8; U64];

// A slice is a pointer to an array of data with a constant length
// with a maximum value of max!U16.
gen!![T] // generic
( 
  struct Slice: [
    _al: U16; // align
    len: U16;
    ptr: Ptr;
  ];

  // Implementing methods
  fn Slice.slotSize: [] -> stk[U32] do sizeOf! T;


  // Of course, some of this can be inlined -- and is through constant folding.
  fn Slice.get: stk[/*sliceRef*/ &Slice[T], /*index*/ U32] -> stk[T] do (
    // ... implementation
  );
);

// Structs are instantiated using `{}` and are themselves an expression.
fn createU32SliceRaw: [ptr: Ptr; len: U16] -> Slice do {
    _al = 0;
    len = len;
    ptr = ptr;
};

// Enums can contain values.
enum ExampleEnum: [
  none: []; // void i.e. no value
  int: I32;
  str: Str;
  both: [int: I32; str: Str];
];

// Example simple use.
fn is3: [v: MaybeIntOrStr] -> Bool do (
  switch v
  case none do false;
  case int  do int == 3;
  case str  do false;
  case both do both.int == 3;
);
