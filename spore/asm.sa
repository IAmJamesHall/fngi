.4

// # Memory Locations
#0000_0000 =rNull
#0000_0004 =rHeap // heap reference
#0000_0008 =rTopHeap
#0000_000C =rTopMem

// # Instructions

// Size
#C000_0000 =Sz1
#C000_4000 =Sz2
//   _8000 =reserved
#C000_C000 =Sz4
#C000_C000 =SzA // APtr

// Jmp
#3800_0000 =NOJ
#3800_0800 =JZ
#3800_1000 =JTBL
#3800_1800 =JST
//   _2000 =reserved
#3800_2800 =CALL
#3800_3000 =CNL
#3800_3800 =RET

// Mem
#01C0_0000 =WS
#01C0_0040 =IMWS
#01C0_0080 =FTLI
#01C0_00C0 =FTMI
#01C0_0100 =FTOI
#01C0_0140 =SRLI
#01C0_0180 =SRMI
#01C0_01C0 =SROI

// Operations

#003F_0000 =NOP
#003F_0001 =DVF
#003F_0002 =DVS
#003F_0003 =FT
#003F_0004 =SR
#003F_0005 =DRP
#003F_0006 =INV
#003F_0007 =NEG
#003F_0008 =EQZ
#003F_0009 =EQZ_NC
#003F_000A =DRP2
#003F_000B =OVR
#003F_000C =ADD
#003F_000D =SUB
#003F_000E =MOD
#003F_000F =MUL

#003F_0010 =DIV_U
#003F_0011 =DIV_S
#003F_0012 =OR
#003F_0013 =XOR
#003F_0014 =SHL
#003F_0015 =SHR
#003F_0016 =EQU
#003F_0017 =NEQ
#003F_0018 =GE_U
#003F_0019 =GE_S
#003F_001A =LT_U
#003F_001B =LT_S

// Note: instr commands are 4 bytes to make working with masks
// easier. Only the lower 2 bytes are used.

// # Device Operations
/ #1 =2 D_read   // {count:2} read bytes from src
/ #2 =2 D_scan   // scan next word into tokenBuf[0:tokenLen]
/ #3 =2 D_dict4  // FT=get SR=set 4byte dict value in tokenBuf
/ #4 =2 D_instr  // {instr:4} get/set cached instr.
/ #5 =2 D_sz     // {sz:1} get/set current sz in bytes



