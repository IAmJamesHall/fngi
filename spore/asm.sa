.4

// # Memory Locations
#0000_0000 =rNull
#0000_0004 =rHeap // heap reference
#0000_0008 =rTopHeap
#0000_000C =rTopMem

// # Instructions

// Jmp
#E000_0000 =NOJ
#E000_2000 =JZ
#E000_4000 =JTBL
#E000_600 =JST
//   _8000 =reserved
#E000_A000 =CALL
#E000_C000 =CNL
#E000_E000 =RET

// Mem
#0700_0000 =WS
#0700_0100 =IMWS
#0700_0200 =FTLI
#0700_0300 =FTMI
#0700_0400 =FTOI
#0700_0500 =SRLI
#0700_0600 =SRMI
#0700_0700 =SROI

// Size
#0000_0000 =SzMask
#00C0_0000 =Sz1
#00C0_0040 =Sz2
//   _0080 =reserved
#00C0_00C0 =Sz4
#00C0_00C0 =SzA // APtr

// Operations
#003F_0000 =NOP
#003F_0001 =DVF
#003F_0002 =DVS
#003F_0003 =FT
#003F_0004 =SR
#003F_0005 =DRP
#003F_0006 =INV
#003F_0007 =NEG
#003F_0008 =EQZ
#003F_0009 =EQZ_NC
#003F_000A =DRP2
#003F_000B =OVR
#003F_000C =ADD
#003F_000D =SUB
#003F_000E =MOD
#003F_000F =MUL

#003F_0010 =DIV_U
#003F_0011 =DIV_S
#003F_0012 =OR
#003F_0013 =XOR
#003F_0014 =SHL
#003F_0015 =SHR
#003F_0016 =EQU
#003F_0017 =NEQ
#003F_0018 =GE_U
#003F_0019 =GE_S
#003F_001A =LT_U
#003F_001B =LT_S

// Note: instr commands are 4 bytes to make working with masks
// easier. Only the lower 2 bytes are used.

// # Device Operations
/ #1 =2 D_read   // {count:2} read bytes from src
/ #2 =2 D_scan   // scan next word into tokenBuf[0:tokenLen]
/ #3 =2 D_dict4  // FT=get SR=set 4byte dict value in tokenBuf
/ #4 =2 D_instr  // {instr:4} get/set cached instr.
/ #5 =2 D_sz     // {sz:1} get/set current sz in bytes



