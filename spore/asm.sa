
.4
// # Memory Locations
#0000_0000 =rNull
#0000_0004 =rHeap // heap reference
#0000_0008 =rTopHeap
#0000_000C =rTopMem

// # Instructions

// Jmp
#E000_0000 =NOJ
#E000_2000 =JZ
#E000_4000 =JTBL
#E000_600 =JST
//   _8000 =reserved
#E000_A000 =CALL
#E000_C000 =CNL
#E000_E000 =RET

// Mem
#0700_0000 =WS
#0700_0100 =IMWS
#0700_0200 =FTLI
#0700_0300 =FTMI
#0700_0400 =FTOI
#0700_0500 =SRLI
#0700_0600 =SRMI
#0700_0700 =SROI

// Size
#00C0_0000 =Sz1
#00C0_0040 =Sz2
#00C0_0080 =Sz4
#00C0_0080 =SzA   // APtr

// Operations: Special
#003F_0000 =NOP     // { -> }     no operation
#003F_0001 =SWP     // {l r -> r l} swap
#003F_0002 =DRP     // {l -> }    drop
#003F_0003 =DRP2    // {l r -> }  drop 2
#003F_0004 =DUP     // {l -> l l} duplicate
#003F_0005 =DUPN    // {l -> l l==0} DUP then NOT
#003F_0006 =DVL     // Device Operation Load
#003F_0007 =DVS     // Device Operation Store
#003F_0008 =RGL     // Register Load
#003F_0009 =RGS     // Register Store
#003F_000A =FT      // Fetch
#003F_000B =SR      // Store

// Operations: One Inp {l} -> One Out
#003F_0010 =INC     // {l+1}  increment 1
#003F_0011 =INC2    // {l+2}  increment 2
#003F_0012 =INC4    // {l+4}  increment 4
#003F_0013 =INV     // {~l}   Bitwise Inversion
#003F_0014 =NEG     // {-l}   Negate (2's compliment)
#003F_0015 =NOT     // {l==0} Logical NOT
#003F_0016 =CI1     // {ISz}  Convert I1 to ISz
#003F_0017 =CI2     // {ISz}  Convert I2 to ISz
// future: leading 0's, trailing 0's, count of 1's
// Some single-arg extension commands might be:
// (7) floating point abs, negative, ceil, floor, trunc, nearest, and sqrt
// (1) i -> f conversion
// (1) f -> i conversion

// Operations: Two Inp {l r} -> One Out
#003F_0020 =ADD   // {l +  r } add
#003F_0021 =SUB   // {l -  r } subtract
#003F_0022 =MOD   // {l %  r } integer modulo (remainder)
#003F_0023 =SHL   // {l << r } bit shift left
#003F_0024 =SHR   // {l >> r } bit shift right
#003F_0025 =AND   // {l &  r } bitwise and
#003F_0026 =OR    // {l |  r } bitwise or
#003F_0027 =XOR   // {l ^  r } bitwise xor
#003F_0028 =LAND  // {l && r } logical and
#003F_0029 =LOR   // {l || r } logical or
#003F_002A =EQ    // {l == r } equal
#003F_002B =NEQ   // {l != r } not equal
#003F_002C =GE_U  // {l >= r } unsigned greater than or equal
#003F_002D =LT_U  // {l <  r } unsigned less than
#003F_002E =GE_S  // {l >= r } signed greater than or equal
#003F_002F =LT_S  // {l <  r } signed less than

#003F_0030 =MUL   // {l *  r } multiplication
#003F_0031 =DIV_U // {l / r  } unsigned division
#003F_0032 =DIV_S // {l / r  } signed division
// Double-arg extension commands might be:
// floating point: add,sub,mul,div,ge,lt

/ // # Device Operations
/ #00 =D_read   // {count:2} read bytes from src
/ #00 =D_scan   // scan next word into tokenBuf[0:tokenLen]
/ #00 =D_dict   // FT=get SR=set dict value of sz from tokenBuf
/ #00 =D_instr  // get/set cached instr (2 bytes).
/ #00 =D_sz     // get/set current sz in bytes
