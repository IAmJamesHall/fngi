
.4
// # Memory Locations
#0000_0000 =rNull
#0000_0004 =rHeap // heap reference
#0000_0008 =rTopHeap
#0000_000C =rTopMem

// # Instructions

// Jmp
#E000_0000 =NOJ
#E000_2000 =JZ
#E000_4000 =JTBL
#E000_600 =JST
//   _8000 =reserved
#E000_A000 =CALL
#E000_C000 =CNL
#E000_E000 =RET

// Mem
#0700_0000 =WS
#0700_0100 =IMWS
#0700_0200 =FTLI
#0700_0300 =FTMI
#0700_0400 =FTOI
#0700_0500 =SRLI
#0700_0600 =SRMI
#0700_0700 =SROI

// Size
#00C0_0000 =Sz1
#00C0_0040 =Sz2
#00C0_0080 =Sz4
#00C0_0080 =SzA   // APtr

// Operations: Special
#003F_0000 =NOP   // no operation
//   _0001        // reserved
#003F_0002 =DVL   // Device Operation Load
#003F_0003 =DVS   // Device Operation Store
#003F_0004 =RGL   // Register Load
#003F_0005 =RGS   // Register Store
#003F_0006 =FT    // Fetch
#003F_0007 =SR    // Store

// Operations: Single Arg
#003F_0008 =DRP     // {v -> } drop
#003F_0009 =DUP     // {v -> v v} duplicate
#003F_000A =INC     // {v -> v+1} increment 1
#003F_000B =INC2    // {v -> v+2} increment 2
#003F_000C =INC4    // {v -> v+4} increment 4
#003F_000D =INV     // {v -> ~v}  Invert bits
#003F_000E =NEG     // {v -> -v}  Negate (2's compliment)
#003F_000F =EQZ     // {v -> v==0}
#003F_0010 =EQZ_NC  // {v -> v v==0}

// Operations: Two Arg
#003F_0018 =DRP2  // {l r -> } drop 2
#003F_0019 =SWP   // {l r -> r l} swap
#003F_001A =ADD   // {l r -> l+r}
#h03F_001B =SUB   // {l r -> l-r}
#003F_001C =MOD   // {l r -> l%r} interger modulo (remainder)
#003F_001D =SHL   // {l r -> l << r} bit shift left
#003F_001E =SHR   // {l r -> l >> r} bit shift right

/ #003F_0000 =AND   // {l r} -> {l & r} bitwise and
/ #003F_0000 =OR    // {l r} -> {l | r} bitwise or
/ #003F_0000 =XOR   // {l r} -> {l ^ r} bitwise xor
/ #003F_0000 =EQ    // {l r} -> {l == r} equal
/ #003F_0000 =NEQ   // {l r} -> {l != r} not equal
/ #003F_0000 =GE_U  // {l r} -> {l >= r} unsigned
/ #003F_0000 =GE_S  // {l r} -> {l >= r} signed
/ #003F_0000 =LT_U  // {l r} -> {l <  r} unsigned
/ #003F_0000 =LT_S  // {l r} -> {l <  r} signed

// Extensions
// #003F_0000 =MUL
// #003F_0000 =DIV_U
// #003F_0000 =DIV_S
// #003F_0000 =OVR

// # Device Operations
#00 =D_read   // {count:2} read bytes from src
#00 =D_scan   // scan next word into tokenBuf[0:tokenLen]
#00 =D_dict   // FT=get SR=set dict value of sz from tokenBuf
#00 =D_instr  // get/set cached instr (2 bytes).
#00 =D_sz     // get/set current sz in bytes
