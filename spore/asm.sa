// Spore assembly constants.
//
// Bit layout of an instruction (X=unused)
//    Jmp    Mem   Sz Operation
//    JJJ XX MMM   SS OO OOOO
//   | high byte |  low byte |

.4
// **********
// * Memory Locations
#0000_0000 =rNull
#0000_0004 =rHeap // heap reference
#0000_0008 =rTopHeap
#0000_000C =rTopMem

// **********
// * Instructions
// # Jmp          // Description
#E000_0000 =NOJ   // No Jump
#E000_2000 =JZL   // Jmp to Literal if store==0
#E000_4000 =JTBL  // JTBL consume store and jump to table using size=Literal
#E000_6000 =JMPW   // Jump
//   _8000 =res   // reserved
#E000_A000 =XW    // Execute from WS, updating LS using size at address.
#E000_C000 =XSW   // "Micro" (u) call from WS, no LS size at address.
#E000_E000 =RET   // Return

// # Mem          // Top         Store    Description
#0700_0000 =WS    // WS          WS       Working Stack
#0700_0100 =LIT   // LIT         WS       Literal
#0700_0200 =FTLL  // FT(LP+LIT)  WS       FeTch LocalsPtr offset
#0700_0300 =FTML  // FT(MP+LIT)  WS       FeTch ModulePtr offset
#0700_0400 =FTOL  // FT(WS)      WS       FeTch Operate Literal
#0700_0500 =SRLL  // FT(LP+LIT)  &LP+LIT  StoRe LocalsPtr offset
#0700_0600 =SRML  // FT(MP+LIT)  &MP+LIT  StoRe ModulePtr offset
#0700_0700 =SROL  // WS          &LIT     StoRe Operate Literal

// # Size
#00C0_0000 =Sz1   // 1 byte, .1
#00C0_0040 =Sz2   // 2 byte, .2
#00C0_0080 =Sz4   // 4 byte, .4
#00C0_0080 =SzA   // APtr,   .A

// # Operations: Special
#003F_0000 =NOP   // { -> }     no operation
#003F_0001 =SWP   // {l r -> r l} swap
#003F_0002 =DRP   // {l -> }    drop
#003F_0003 =DRP2  // {l r -> }  drop 2
#003F_0004 =DUP   // {l -> l l} duplicate
#003F_0005 =DUPN  // {l -> l l==0} DUP then NOT
#003F_0006 =DVF   // Device Operation Load
#003F_0007 =DVS   // Device Operation Store
#003F_0008 =RGL   // Register Load
#003F_0009 =RGS   // Register Store
#003F_000A =FT    // Fetch
#003F_000B =SR    // Store
#003F_000C =LIT4  // { -> U4} push 4byte literal
#003F_000D =ZERO  // { -> 0} push zero onto WS

// # Operations: One Inp {l} -> One Out
#003F_0010 =INC   // {l+1}  increment 1
#003F_0011 =INC2  // {l+2}  increment 2
#003F_0012 =INC4  // {l+4}  increment 4
#003F_0013 =INV   // {~l}   Bitwise Inversion
#003F_0014 =NEG   // {-l}   Negate (2's compliment)
#003F_0015 =NOT   // {l==0} Logical NOT
#003F_0016 =CI1   // {ISz}  Convert I1 to ISz
#003F_0017 =CI2   // {ISz}  Convert I2 to ISz
// future: leading 0's, trailing 0's, count of 1's
// Some single-arg extension commands might be:
// (7) floating point abs, negative, ceil, floor, trunc, nearest, and sqrt
// (1) i -> f conversion
// (1) f -> i conversion

// # Operations: Two Inp {l r} -> One Out
#003F_0020 =ADD   // {l +  r } add
#003F_0021 =SUB   // {l -  r } subtract
#003F_0022 =MOD   // {l %  r } integer modulo (remainder)
#003F_0023 =SHL   // {l << r } bit shift left
#003F_0024 =SHR   // {l >> r } bit shift right
#003F_0025 =AND   // {l &  r } bitwise and
#003F_0026 =OR    // {l |  r } bitwise or
#003F_0027 =XOR   // {l ^  r } bitwise xor
#003F_0028 =LAND  // {l && r } logical and
#003F_0029 =LOR   // {l || r } logical or
#003F_002A =EQ    // {l == r } equal
#003F_002B =NEQ   // {l != r } not equal
#003F_002C =GE_U  // {l >= r } unsigned greater than or equal
#003F_002D =LT_U  // {l <  r } unsigned less than
#003F_002E =GE_S  // {l >= r } signed greater than or equal
#003F_002F =LT_S  // {l <  r } signed less than

#003F_0030 =MUL   // {l *  r } multiplication
#003F_0031 =DIV_U // {l / r  } unsigned division
#003F_0032 =DIV_S // {l / r  } signed division
// Double-arg extension commands might be:
// floating point: add,sub,mul,div,ge,lt

// **********
// * Device Operations
#00 =D_read   // read from src, filling up tokenBuf
#01 =D_scan   // scan next word into tokenBuf[0:tokenLen]
#02 =D_dict   // FT=get SR=set dict key=tokenBuf
#03 =D_rdict  // FT=get reference to val  SR=forget including key
#04 =D_instr  // get/set cached instr. Set uses `mask | instr` like asm.
#05 =D_sz     // get/set current sz in bytes
#06 =D_comp   // compile the token in tokenBuf
#07 =D_assert // error if != 0
#08 =D_wslen  // working stk len
#09 =D_cslen  // call stk len

// **********
// * Compiler Constants
.4
@rTopMem FT^    #8 SUB^   =c_rDictArray  // Dict struct
@c_rDictArray   INC4^     =c_rDictHeap
@c_rDictArray   #8 SUB^   =c_rTokenBuf   // TokenBuf struct
@c_rTokenBuf    INC4^     =c_rTokenLen

// **********
// * Global Constants
.4
#8000 =C_CMP_EQ   // Comparison was equal. Was less if LT this, vice-versa.

// Errors:
#E000 =E_Unknown // unknown error
#E001 =E_Test    // test failure

// [E010-E020) Input/Output errors
#E010 =E_IO // unknown IO

// [E020-E030) General purpose errors
#E0C1 =E_WsNotEmpty

// [E0C0-E0C0) Compiler errors
#E0C0 =E_C // unknown compiler
#E0C1 =E_CDictDNE

// Errors [E000 - E100): reserved for built-in errors.
// E100: device-specific hardware errors
// [E200-E800): reserved
// E800+: application errors
