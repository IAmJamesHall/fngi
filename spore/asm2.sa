// This file creates some essential assembly utilities including

// **********
// * Essential macros:
// These macros must be defined in pure ASM. They build on eachother
// to make the syntax much more readable.

@vHeap .4 FT^ =h2  // h2: {val:2} push 2bytes from stack to heap
  .4 FTML SWP; .2@vHeap,  // fetch heap and swap {heap, val}
  .2      SR;             // store 2 byte value at heap
  .4 FTML INC2; .2@vHeap, // fetch heap and increment by 2
  .4 SRML  RET; .2@vHeap, // store new heap and return

@vHeap .4 FT^ =h4  // h4: {val:4} push 4bytes from stack to heap
  .4 FTML SWP; .2@vHeap,  // ft heap
  .4      SR;             // sr 4byte value
  .4 FTML INC4; .2@vHeap, // ft heap and +4
  .4 SRML  RET; .2@vHeap, // sr new heap

// {v:4} compile a LIT4 (value-only) to the heap for LIT4.
// Note: compiled as two U2 values with largest first.
@vHeap .4 FT^ =hL4
  // Duplicate, then call h2(v>>0x10)
  DUP;   LIT SHR XSL; #10 $h2  @h2 $h2 // Compile high bits
  JMPL; @h2 $h2

@vHeap .4 FT^ =_dict // setup for dict
  .4 LIT DVF; @D_scan $h2
  .4 FTML; @c_vDictBuf $h2 // dict.buf
  .2 LIT RET; @c_vDictHeap $h2 // &dict.heap

@vHeap .4 FT^ =dictSet // dctSet: Set "standard" dictionary to next token.
  .4 XSL; @_dict $h2
  .4 LIT DVS RET; .2@D_dict,

@vHeap .4 FT^ =c_setRKeyMeta // {mask:U1} mask current key's 8bit meta
  .4 FTML INC4; @c_vRKey $h2 // fetch {mask &key.meta}
  .1 FT; // fetch 1 byte {mask meta}
  .1 OR;
  .4 FTML INC4; @c_vRKey $h2
  .1 SR RET;

// Define $loc for cleaner function/etc names.
// This creates a name and sets up for local variables.
@vHeap .4 FT^ =loc
  // update rKey
  .4 FTML; @c_vDictBuf $h2 // dict.buf
  .2 FTML; @c_vDictHeap $h2 // dict.heap
  .4 ADD SRML; @c_vRKey $h2 // rKey=dict.buf + dict.heap

  // // set rKey as fn type
  .4 LIT XSL; @IS_FN $h2 @c_setRKeyMeta $h2

  // Set dict[nextToken] = heap
  .4 FTML XSL; @vHeap $h2 @dictSet $h2

  // clear locals by setting localDict.heap=dict.heap (start of localDict.buf)
  .2 SRML ZERO; @c_vLocalOffset $h2   // zero localDict.offset
  .2 SRML ZERO RET; @c_vDictLHeap $h2 // zero localDict.heap

$loc dictGet   // { -> v}
  .4 XSL; @_dict $h2
  .4 LIT DVF RET; @D_dict $h2

.4
$loc getHeap     FTML RET; @vHeap $h2
$loc setHeap     SRML RET; @vHeap $h2
$loc getTopHeap  FTML RET; @vTopHeap $h2
$loc setTopHeap  SRML RET; @vTopHeap $h2
$loc getSz       LIT DVF RET; @D_sz $h2
$loc setSz       LIT DVS RET; @D_sz $h2
$loc getWsLen    LIT DVF RET; @D_wslen $h2
$loc c_xsCatch   LIT DVF RET; @D_xsCatch $h2
$loc c_scan      LIT DVF RET; @D_scan $h2
$loc c_asemble   LIT DVS RET; @D_comp $h2
$loc c_assembleNext // scan and assemble
  LIT DVF; @D_scan $h2
  LIT DVS RET; @D_comp $h2

.4 $loc c_maskInstr
  LIT DVS RET; @D_instr $h2 // use mask on instr

.4 $loc c_compMaskInstr // {maskInstr:4}
  LIT DVS; @D_instr $h2 // use mask on instr
  LIT DVF; @D_instr $h2 // get instr
  XSL; @h2 $h2 // compile instr to heap

  // Clear current instr (preserves sz)
  LIT4; @CLR_INSTR $hL4
  LIT DVS RET; @D_instr $h2

// Assert checks a condition or panics with an error
// ex: <some check> @E_myError assert
$loc assertNot SWP; NOT; SWP; // ... intentional fallthrough
$loc assert    LIT DVF RET; @D_assert $h2
$loc panic     LIT SWP JMPL; #0 $h2 @assert $h2 // Panic with an error code

// **********
// * Core macros:
// These are used for executing code with combined instructions and literals,
// as well as setting up forward jumps.
//
// These are combined with the current instruction, using whatever size it is.
//   Ex: `ADD $xsl foo`         -> `ADD XSL; @foo $h2`
// The mem_* variants also include a 2byte literal for use with an arbitrary mem:
//   Ex: `ADD LIT #321 $mem_xsl foo` -> `LIT ADD XSL; #321 $h2 @foo $h2`
//
// Additionally, `$L` or `$retL` can be used to only push literals. They are
// smart and use LIT or LIT4 depending on the size of the value. Note: they
// ignore current instr since LIT4 is an operation.
//   Ex: $L@myVar   $L#1234_5678   $retL#3

$loc topU4And // {v:U4 mask:U1} mask upper 8bits of U4
  .4 LIT SHL; #18 $h2 // mask=mask << 24
  .4 AND RET;

$loc chkXNoLocals // {metaFnAddr -> fnAddr}
  // Assert is not local
  .4 DUP; // {metaFnAddr, metaFnAddr}
  .4 LIT XSL; @IS_LARGE_FN $h2  @topU4And $h2 // {metaFnAddr isLocal}
  .4 LIT XSL; @E_cXHasL $h2  @assertNot $h2  // {metaFnAddr}
  .4 LIT4; #FF_FFFF $hL4
  .4 AND RET;

.4 $loc xsl // compile instr with XSL, see docs on core macros.
  LIT4 XSL; @XSL $hL4  @c_compMaskInstr $h2 // compile instr with XSL
  XSL; @dictGet $h2 // get next token's ptr
  XSL; @chkXNoLocals $h2 // check that it's valid
  JMPL; @h2 $h2 // put on stack

.4 $loc jmpl // compile instr with JMPL, see docs on core macros.
  LIT4 XSL; @JMPL $hL4  @c_compMaskInstr $h2 // compile with JMPL
  $xsl dictGet // get next token's ptr
  $xsl chkXNoLocals // check that it's valid
  JMPL; @h2 $h2 // put on stack

.4 $loc mem_xsl // compile mem+instr with XSL, see docs on core macros.
  LIT4 XSL; @XSL $hL4 @c_compMaskInstr $h2 // compile w/XSL
  $xsl h2 // compile lit
  $xsl dictGet // get next token value
  $xsl chkXNoLocals // check that it's valid
  $jmpl h2 // compile it

.4 $loc mem_jmpl // compile mem+instr with JMPL, see docs on core macros.
  LIT4 XSL; @JMPL $hL4 @c_compMaskInstr $h2 // compile w/JMPL
  $xsl h2 // compile literal
  $xsl dictGet // get next token value
  $xsl chkXNoLocals // check that it's valid
  $jmpl h2 // compile it

$loc chkXLocals // {metaFnAddr -> fnAddr}
  // Assert is not local
  .4 DUP; // {metaFnAddr metaFnAddr}
  .4 LIT @IS_LARGE_FN $mem_xsl topU4And // {metaFnAddr isLocal}
  .4 LIT @E_cXNoL $mem_xsl assert // {metaFnAddr}
  LIT4; #FF_FFFF $hL4 // {metaFnAddr fnAddrMask}
  AND RET;

.4 $loc xl // compile instr with XL, see docs on core macros.
  LIT4 XSL; @XL $hL4 @c_compMaskInstr $h2 // compile w/XL
  $xsl dictGet // get next token value
  $xsl chkXLocals // check that it's valid
  $jmpl h2 // compile it

.4 $loc mem_xl // compile mem+instr with XL, see docs on core macros.
  LIT4 XSL; @XL $hL4 @c_compMaskInstr $h2 // compile w/XL
  $xsl h2 // compile lit
  $xsl dictGet // get next token value
  $xsl chkXLocals // check that it's valid
  $jmpl h2 // compile it

// **********
// * ASM Flow Control
// - `$IF ... $END` for if blocks
// - `$LOOP ... $BREAK0 ... $AGAIN $END` for infiinte loops with breaks.
//
// All flow control pushes the current heap on the WS, then END/AGAIN correctly
// stores/jmps the heap where they are called from.

.4 $loc IF
  LIT4 XSL; @JZL $hL4  @c_compMaskInstr $h2 // compile with JZL
  $xsl getHeap // push location for END
  LIT #1BAD $mem_jmpl h2 // compile 1BAD to jmp location

.4 $loc mem_IF
  LIT4 XSL; @JZL $hL4  @c_compMaskInstr $h2 // compile with JZL
  $xsl h2 // compile literal
  $xsl getHeap // push location for END
  LIT #1BAD $mem_jmpl h2 // compile 1BAD to jmp location

.4 $loc END $xsl getHeap   .2 SR RET;

// $LOOP ... $BREAK0 ... $AGAIN $END
$loc LOOP   $jmpl getHeap // push location for AGAIN
$loc BREAK0 $xsl IF   SWP RET;
$loc mem_BREAK0 $xsl mem_IF   SWP RET;
$loc AGAIN
  LIT4 XSL; @JMPL $hL4  @c_compMaskInstr $h2 // compile with JMPL
  $jmpl h2 // compile location to jmp to

// **********
// * Literals
// $L @myValue allows for easier pushing of literals. It automatically handles
// 2 or 4 byte literals.

.4 $loc L // compile next value as literal
  $xsl c_assembleNext // assemble next token (i.e. @myVal)
  // Check if it is >= #10000 and use LIT4, else LIT
  DUP;  LIT INC; #FFFF $h2  GE_U $IF
    @Sz4 @LIT4 ADD^  LIT $mem_xsl h2 // compile {.4 LIT4}
    $jmpl hL4 // compile 4byte literal value.
  $END
    @Sz2 @LIT ADD^   LIT $mem_xsl h2 // compile {.2 LIT}
    $jmpl h2 // compile 2byte literal value.

.4 $loc retL // compile next value as literal and return
  $xsl c_assembleNext // assemble next token (i.e. @myVal)
  // Check if it is >= #10000 and use LIT4, else LIT
  DUP;  LIT INC; #FFFF $h2   GE_U $IF
    @Sz4 @LIT4 @RET ADD^ADD^  LIT $mem_xsl h2 // compile {.4 LIT4 RET}
    $jmpl hL4 // compile 4byte literal value.
  $END
    @Sz2 @LIT @RET ADD^ADD^   LIT $mem_xsl h2 // compile {.2 LIT RET}
    $jmpl h2 // compile 2byte literal value.


// **********
// * Utilities

// $XX: instantly execute non-small function.
// Ex: $XX foo, where foo has local variables.
$loc XX $xsl dictGet  $xsl chkXLocals  XW; RET;

// Get next token dict reference
$loc dictGetR     $xsl c_scan  .4 LIT DVF RET; @D_rdict $h2

.4 $loc hAlign4 // align heap
  $xsl getHeap  DUP;
  LIT MOD; #4 $h2 // {heap heap%4}
  DUP $IF
    SUB;
    ADD LIT #4 $mem_jmpl setHeap // heap = heap - (heap%4) + 4
  $END  DRP2 RET;

.4

$loc assertWsEmpty  $xsl getWsLen  $L @E_wsEmpty  $jmpl assertNot
$loc tAssert        LIT @E_test $mem_jmpl assert
$loc tAssertNot     LIT @E_test $mem_jmpl assertNot
$loc tAssertEq      .4 EQ  $jmpl tAssert
$loc tAssertNe      .4 NEQ $jmpl tAssert

// **********
// * Local Variables
// Local variables are simply offsets that are fetch/store using FTLL and SRLL
// They are defined like:
// $loc foo
//   #4 $decl_lo a
//   #2 $decl_lo b
//   $end_lo
//   SRLL ZERO; $lo a $h2 // a = 0

$loc c_setRKeyFnMeta // {mask:U1} mask upper 8bits (fn meta) of current key's value
  .4 LIT SHL; #18 $h2 // mask=mask << 24
  .4 FTML FT; @c_vRKey $h2 // double fetch {mask key.value}
  .4 OR; // { maskedValue }
  FTML SWP; @c_vRKey $h2 // { &key newValue }
  .4 SR RET;

$loc _lDict
  .4 LIT DVF    ; .2@D_scan,
  // localDict.buf = dict.buf + dict.heap
  .4 LIT4; @c_vDictBuf $hL4  .4 FT;
  .4 LIT4; @c_vDictHeap $hL4 .2 FT;
  ADD;
  .4 LIT4 RET; @c_vDictLHeap $hL4    // &localDict.heap

$loc lDictSet $xsl _lDict   .4 LIT DVS RET; @D_dict $h2 // {value}
$loc lo $xsl _lDict   .4 LIT DVF RET; @D_dict $h2 // {-> value}

$loc alignSz // {value sz -> aligned} align value by sz bytes
  @IS_LARGE_FN $c_setRKeyFnMeta
  #1 $h2 // locals (4bytes)
  .2 SRLL; #0 $h2 // l0=sz
  .4 DUP; FTLL MOD; #0 $h2 // {value value%sz}
  DUP $IF
    SUB;
    FTLL ADD RET; #0 $h2 // return: value - value%sz + sz
  $END   DRP RET;        // return: value

// {sz}: Declare a local variable offset.
// Ex: `#4 $decl_lo foo` declares local variable of sz=4
//
// It is the job of the programmer to ensure they are aligned.
$loc decl_lo
  .4 DUP; // {sz sz}
  .2 FTML SWP @c_vLocalOffset $mem_xl alignSz // {sz alignedOffset}
  .4 DUP $xsl lDictSet // set next token to alignedOffset {sz alignedOffset}
  .2 ADD SRML RET; @c_vLocalOffset $h2 // add together and update vLocalOffset

$loc end_lo // use the current declared local offsets to define the locals size
  LIT @IS_LARGE_FN $mem_xsl c_setRKeyFnMeta // make it a locals fn
  .2 FTML; @c_vLocalOffset $h2
  LIT #4 $mem_xl alignSz
  SHR LIT #2 $mem_jmpl h2 // shift right 2 (divide by 4) and store.

$loc getl // get a local variable
  LIT4 XSL; @FTLL $hL4 @c_compMaskInstr $h2
  $xsl lo // get next local token value (offset)
  JMPL; @h2 $h2 // put on stack (literal)

$loc setl // set a local variable
  LIT4 XSL; @SRLL $hL4 @c_compMaskInstr $h2
  $xsl lo // get next local token value (offset)
  JMPL; @h2 $h2 // put on stack (literal)

$assertWsEmpty
