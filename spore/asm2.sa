// This file creates some essential assembly utilities including

// Define $loc
.4@rHeap FT^ =loc // fetch current heap and set to loc
  FTMI        ; .2@rHeap,  // fetch heap {heap:4}
  .4 IMWS DVL    ; .2@D_scan,   // scan next token into tokenBuf {heap}
  .4 IMWS DVS RET; .2@D_dict,   // set dict key(tokenBuf) to current heap

.4 $loc dictSet / {v}
  .4 IMWS DVL    ; .2@D_scan,
  .4 IMWS DVS RET; .2@D_dict,
$loc dictGet / { -> v}
  .4 IMWS DVL    ; .2@D_scan,
  .4 IMWS DVL RET; .2@D_dict,

$loc h2  // {val:2} push 2bytes from stack to heap
  .4 FTMI SWP; .2@rHeap,  // fetch heap and swap {heap, val}
  .2      SR;             // store 2 byte value at heap
  .4 FTMI INC2; .2@rHeap, // fetch heap and increment by 2
  .4 SRMI  RET; .2@rHeap, // store new heap and return

.4
$loc getHeap     FTMI RET; @rHeap $h2
$loc setHeap     SRMI RET; @rHeap $h2
$loc getTopHeap  FTMI RET; @rTopHeap $h2
$loc setTopHeap  SRMI RET; @rTopHeap $h2
$loc getSz       IMWS DVL RET; @D_sz $h2
$loc setSz       IMWS DVS RET; @D_sz $h2
$loc getWsLen    IMWS DVL RET; @D_wslen $h2

.2 $loc c_IM // compile an immediate from the stack {v:2}
  IMWS;  @Sz2 @IMWS ADD^, // push `.2 IMWS` instruction to stack
  IMWS CNL; @h2, // compile it
  IMWS JMP; @h2, // compile value

.4 $loc c_CNL / {loc} compile a cnl
  @Sz4 @IMWS @CNL ADD^ ADD^ $c_IM // push .4 IMWS CNL instr
  IMWS CNL; @h2 $h2 // compile it.
  IMWS JMP; @h2 $h2 // compile the loc

.4 $loc c_JMP / {loc} compile a jmp
  @Sz4 @IMWS @JMP ADD^ ADD^ $c_IM // push .4 IMWS JMP instr
  @h2 $c_CNL // compile it
  IMWS JMP; @h2 $h2 // compile the loc

.4 $loc c_FTMI4 / {loc} compile a fetch immediate sz=4
  @Sz4 @FTMI ADD^ $c_IM // push .4 FTMI instr
  @h2 $c_CNL // compile it
  IMWS JMP; @h2 $h2 // compile the loc

.4 $loc c_FTMI2 / {loc} compile a fetch immediate sz=2
  @Sz2 @FTMI ADD^ $c_IM // push .2 FTMI instr
  @h2 $c_CNL // compile it
  IMWS JMP; @h2 $h2 // compile the loc

// **********
// * Jump location setup and update
.2 $loc jloc // declare a jump location. ex: $jloc jmpTo
  @getHeap $c_CNL   @dictSet $c_CNL // set dict of token to heap
  #BAD $c_IM        @h2 $c_JMP      // set asside space to update

// Update jloc with current 2byte heap. ex: $jset jmpTo
.4 $loc jset
  @dictGet $c_CNL  @getHeap $c_CNL // {addr curHeap}
  .2 SR RET; // store curHeap

// **********
// * Utilities
.4
$loc scan     .4 IMWS DVL RET; @D_scan $h2

// Get next token dict reference
$loc c_dRef     @scan $c_CNL  .4 IMWS DVL RET; @D_rdict $h2

// Forget dict until and including next token
$loc dForget  @scan $c_CNL  .4 IMWS DVS RET; @D_rdict $h2

.4 $loc hAlign4 // align heap
  @getHeap $c_CNL DUP;
  IMWS MOD; #4 $h2 // {heap heap%4}
  DUP JZ; $jloc j_to
    SUB; IMWS ADD; #4 $h2  // heap - (heap%4) + 4
    @setHeap $c_JMP
  $jset j_to
    DRP2 RET;
$dForget j_to

.4
#00 =E_Unknown
#01 =E_WsNotEmpty
#02 =E_DictDNE

$loc assertWsEmpty @getWsLen $c_CNL @E_WsNotEmpty $c_IM // fallthrough
$loc assertFals    SWP; NOT; SWP; // fallthrough
$loc assert        IMWS DVL RET; @D_assert $h2

$hAlign4
$assertWsEmpty
