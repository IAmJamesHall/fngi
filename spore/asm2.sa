// This file creates some essential assembly utilities including

// Define $loc
.4@vHeap FT^ =loc // fetch current heap and set to loc
  FTML        ; .2@vHeap,  // fetch heap {heap:4}
  .4 LIT DVF    ; .2@D_scan,   // scan next token into tokenBuf {heap}
  .4 LIT DVS RET; .2@D_dict,   // set dict key(tokenBuf) to current heap

.4 $loc dictSet / {v}
  .4 LIT DVF    ; .2@D_scan,
  .4 LIT DVS RET; .2@D_dict,
$loc dictGet / { -> v}
  .4 LIT DVF    ; .2@D_scan,
  .4 LIT DVF RET; .2@D_dict,

$loc h2  // {val:2} push 2bytes from stack to heap
  .4 FTML SWP; .2@vHeap,  // fetch heap and swap {heap, val}
  .2      SR;             // store 2 byte value at heap
  .4 FTML INC2; .2@vHeap, // fetch heap and increment by 2
  .4 SRML  RET; .2@vHeap, // store new heap and return

$loc h4  // {val:4} push 4bytes from stack to heap
  .4 FTML SWP; .2@vHeap,  // ft heap
  .4      SR;             // sr 4byte value
  .4 FTML INC4; .2@vHeap, // ft heap and +4
  .4 SRML  RET; .2@vHeap, // sr new heap

// {v:4} compile a LIT4 (value-only) to the heap for LIT4.
// Note: compiled as two U2 values with largest first.
.4 $loc hL4
  // Duplicate, then call h2(v>>0x10)
  DUP;   LIT SHR XSL; #10 $h2  @h2 $h2 // Compile high bits
  JMPL; @h2 $h2

.4
$loc getHeap     FTML RET; @vHeap $h2
$loc setHeap     SRML RET; @vHeap $h2
$loc getTopHeap  FTML RET; @vTopHeap $h2
$loc setTopHeap  SRML RET; @vTopHeap $h2
$loc getSz       LIT DVF RET; @D_sz $h2
$loc setSz       LIT DVS RET; @D_sz $h2
$loc getWsLen    LIT DVF RET; @D_wslen $h2
$loc c_scan      LIT DVF RET; @D_scan $h2
$loc c_asemble   LIT DVS RET; @D_comp $h2
$loc c_assembleNext // scan and assemble
  LIT DVF; @D_scan $h2
  LIT DVS RET; @D_comp $h2
$loc dForget LIT DVF; @D_scan $h2 LIT DVS RET; @D_rdict $h2 // $dForget f

.4 $loc c_compMaskInstr // {maskInstr:4}
  LIT DVS; @D_instr $h2 // use mask on instr
  LIT DVF; @D_instr $h2 // get instr
  XSL; @h2 $h2 // compile instr to heap

  // Clear current instr (preserves sz)
  LIT4; @CLR_INSTR $hL4
  LIT DVS RET; @D_instr $h2

// **********
// * Core macros:
// These are used for executing code with combined instructions and literals,
// as well as setting up forward jumps.
//
// These are combined with the current instruction, using whatever size it is.
//   Ex: `ADD $xsl foo`         -> `ADD XSL; @foo $h2`
// The l2_* variants also include a 2byte literal:
//   Ex: `ADD #021 $l2_xsl foo` -> `LIT ADD XSL; #021 $h2 @foo $h2`
//
// Additionally, `$L` or `$retL` can be used to only push literals (they ignore
// current instr). retL also executes RET. They are smart and use LIT or LIT4
// depending on the size of the value:
//   Ex: $L@myVar   $L#1234_5678   $retL#3

.4 $loc xsl // compile instr with XSL, see docs on core macros.
  LIT4 XSL; @XSL $hL4  @c_compMaskInstr $h2 // compile with XSL
  XSL; @dictGet $h2 // get next token's ptr
  JMPL; @h2 $h2 // put on stack

.4 $loc jmpl // compile instr with JMPL, see docs on core macros.
  LIT4 XSL; @JMPL $hL4  @c_compMaskInstr $h2 // compile with JMPL
  $xsl dictGet // get next token's ptr
  JMPL; @h2 $h2 // put on stack

.4 $loc l2_xsl // compile instr with a LIT XSL, see docs on core macros.
  LIT4; @LIT $hL4 // get LIT maskInstr
  LIT DVS; @D_instr $h2 // use mask on instr
  LIT4 XSL; @XSL $hL4 @c_compMaskInstr $h2 // compile w/XSL
  $xsl h2 // compile literal
  $xsl dictGet // get next token value
  $jmpl h2 // compile it

.4 $loc l2_jmpl // compile instr with a LIT JMPL, see docs on core macros.
  LIT4; @LIT $hL4 // get LIT maskInstr
  LIT DVS; @D_instr $h2 // use mask on instr
  LIT4 XSL; @JMPL $hL4 @c_compMaskInstr $h2 // compile w/JMPL
  $xsl h2 // compile literal
  $xsl dictGet // get next token value
  $jmpl h2 // compile it

// Jump location creation and update
.2 $loc jloc // declare a jump location. ex: $jloc j_to
  $xsl getHeap      $xsl dictSet // set dict of next token to heap
  #BAD $l2_jmpl h2 // set asside space to update
.4 $loc jset // Update jloc with current 2byte heap. ex: $jset j_to
  $xsl dictGet    $xsl getHeap // {addr curHeap}
  .2 SR RET; // store curHeap at addr

.4 $loc L // compile next value as literal
  $xsl c_assembleNext // assemble next token (i.e. @myVal)
  // Check if it is >= #10000 and use LIT4, else LIT
  DUP;  LIT INC; #FFFF $h2  GE_U JZL; $jloc j_2byte
    @Sz4 @LIT4 ADD^  $l2_xsl h2 // compile {.4 LIT4}
    $jmpl hL4 // compile 4byte literal value.
  $jset j_2byte
    @Sz2 @LIT ADD^   $l2_xsl h2 // compile {.2 LIT}
    $jmpl h2 // compile 2byte literal value.
$dForget j_2byte

.4 $loc retL // compile next value as literal and return
  $xsl c_assembleNext // assemble next token (i.e. @myVal)
  // Check if it is >= #10000 and use LIT4, else LIT
  DUP;  LIT INC; #FFFF $h2  GE_U JZL; $jloc j_2byte
    @Sz4 @LIT4 @RET ADD^ADD^  $l2_xsl h2 // compile {.4 LIT4 RET}
    $jmpl hL4 // compile 4byte literal value.
  $jset j_2byte
    @Sz2 @LIT @RET ADD^ADD^   $l2_xsl h2 // compile {.2 LIT RET}
    $jmpl h2 // compile 2byte literal value.
$dForget j_2byte

// **********
// * TODO: remove these
.2 $loc c_LIT // compile a literal from the stack {v:2}
  LIT;  @Sz2 @LIT ADD^ $h2 // push `.2 LIT` instruction to stack
  LIT XSW; @h2 $h2 // compile it
  LIT JMPW; @h2 $h2  // compile value

.4 $loc c_XSW / {loc} compile a cnl
  @Sz4 @LIT @XSW ADD^ ADD^ $c_LIT // push .4 LIT XSW instr
  LIT XSW; @h2 $h2 // compile it.
  LIT JMPW; @h2 $h2  // compile the loc

.4 $loc c_JMPW / {loc} compile a jmp along with current instr
  @Sz4 @LIT @JMPW ADD^ ADD^ $c_LIT // push .4 LIT JMPW instr
  @h2 $c_XSW // compile it
  LIT JMPW; @h2 $h2 // compile the loc

.4 $loc c_FTML4 / {loc} compile a fetch literal sz=4
  @Sz4 @FTML ADD^ $c_LIT // push .4 FTML instr
  @h2 $c_XSW // compile it
  LIT JMPW; @h2 $h2 // compile the loc

.4 $loc c_FTML2 / {loc} compile a fetch literal sz=2
  @Sz2 @FTML ADD^ $c_LIT // push .2 FTML instr
  @h2 $c_XSW // compile it
  LIT JMPW; @h2 $h2 // compile the loc

.4 $loc c_LIT4 // compile a LIT4 from the stack {v:4}
  @Sz4 @LIT4 ADD^ $c_LIT // push `.4 LIT4` instruction to stack
  @h2 $c_XSW // compile it
  @hL4 $c_JMPW // compile the 4byte value

// **********
// * Utilities

// Get next token dict reference
$loc c_dRef     @c_scan $c_XSW  .4 LIT DVF RET; @D_rdict $h2

.4 $loc hAlign4 // align heap
  @getHeap $c_XSW DUP;
  LIT MOD; #4 $h2 // {heap heap%4}
  DUP JZL; $jloc j_to
    SUB; LIT ADD; #4 $h2  // heap - (heap%4) + 4
    @setHeap $c_JMPW
  $jset j_to
    DRP2 RET;
$dForget j_to

.4
$loc assertWsEmpty @getWsLen $c_XSW @E_wsEmpty $c_LIT // fallthrough
$loc assertNot     SWP; NOT; SWP; // fallthrough
$loc assert        LIT DVF RET; @D_assert $h2

$loc tAssert     @E_test $c_LIT  @assert $c_JMPW
$loc tAssertNot  @E_test $c_LIT  @assertNot $c_JMPW
$loc tAssertEq   .4 EQ;          @tAssert $c_JMPW
$loc tAssertNe   .4 NEQ;         @tAssert $c_JMPW

$assertWsEmpty
