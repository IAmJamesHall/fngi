// Bootstrap outselves outside of spore assembly and into spore proper.
//
// Main items we already have through device ports:
// - Token scanner (D_scan). Tokens are the same for spore asm as spore proper.
// - Local offset and location store (D_dict)
// - Assembler (D_comp)
//
// Main items we have to build in asm:
// - Compiler to convert tokens into either executed or compiled words in a
//   function.
// - Ability to read types of words being compiled.
//

// 8bit meta masks
#1 =LCL_MASK // 1=has local stack
#2 =PRE_MASK // 1=is prefix
#4 =IMM_MASK // 1=is immediate
#8 =ALI_MASK // 1=always immediate ($ may alter behavior)

// 4 byte globals
$loc rFN_PTR_MASK  .4 #FFFF_FFFF_FFFF,
$loc rI_CNL      .4 @CNL  @IMWS ADD^,
$loc rI_CALL_IM  .4 @CALL @IMWS ADD^,
$loc rI_CLR_IM   .4 #FFFF_0000, // instr clear

#10 =EXEC_MASK // 1=compiler executes everything

// compiler globals
$loc c_STATE .2 #0,
$loc c_CN_EXEC .2 #0,
$hAlign4

$loc stateClr // {mask}
  NOT;
  FTMI AND; @c_STATE $h2
  SRMI RET; @c_STATE $h2

$loc toMeta   IMWS SHR RET; #18 $h2 // shift to make just 8bit meta
$loc hasPre   IMWS AND RET; @PRE_MASK $h2
$loc hasImm // masks for ALI (always imm) and IMM
  @ALI_MASK $im;
  IMWS OR; @IMM_MASK $h2
  AND RET;
$loc hasLcl   IMWS AND RET; @LCL_MASK $h2
$loc hasExec  IMWS AND RET; @EXEC_MASK $h2

// Force execute a metaFn
$loc forceExec // {metaFn}
  .4 DUP;  @toMeta $c_CNL  @hasLcl $c_CNL // get meta
  SWP;  .4 FTMI AND; @rFN_PTR_MASK $h2 SWP; // get masked fn ptr
  JZ; $jloc j_call  .4 CALL; RET;
  $jset j_call      .4 CNL; RET;
$dForget j_call

// Force compile a metaFn to a value.
$loc forceComp // {metaFn}
  // TODO: make sure token is in same module.

  .4 FTMI; @D_sz $h2 // cache current sz

  // Check if Fn is LCL or not
  .4 DUP;  @toMeta $c_CNL  @hasLcl $c_CNL
  JZ; $jloc j_call
    // is LCL, has locals
    .4 FTMI; @rI_CALL_IM $h2 // fetch CALL mask+instr
    IMWS JMP; $jloc j_end
  $jset j_call
    .4 FTMI; @rI_CNL_IM $h2 // fetch CNL mask+instr
  $jset j_end
  !@##$%^&,.

  .4 IMWS DVS; @D_instr $h2 // mask to current instr
  .4 IMWS DVL; @D_instr $h2 // get current instr
  @h2 $c_CNL // compile instr to heap

  // Clear current instr but keep original Sz
  .4 FTMI; @rI_CLR $h2   ADD^
  IMWS DVS; @D_instr $h2

  @h2 $c_CNL // Compile the fn ptr.
  RET;
$dForget j_call

// Core Spore compiler function. Compiles the current scanned token as a spore
// function, checking for PRE, IMM, ALI and LCL bits appropriately.
$loc comp
  // Load dict ref and check it
  .4 IMWS DVL; @D_scan $h2
  // TODO: check if token is "#"

  .4 IMWS DVL; @D_rdict $h2 // {rValue}
  // Make sure token exists
  .4 DUP;  @E_DictDNE $imm  @assert $c_CNL
  LD; // load it {metaFn}

  // Check the meta for PRE. XOR with preBit to toggle
  .4 DUP;  @toMeta $c_CNL  @hasPre $c_CNL
  .2 FTMI; @c_STATE $h2    @hasPre $c_CNL
  @PRE_MASK $c_IM  @stateClr $c_CNL // clear state.PRE

  XOR JZ; $jloc j_to // Checking for PRE.
    @comp $c_CNL // Pre: simply compile next token
  $jset j_to

  // Check the meta for IMM or EXEC mode
  .4 DUP;  @toMeta $c_CNL  @hasImm $c_CNL
  .2 FTMI; @c_STATE $h2    @hasImm $c_CNL
  // xor to toggle. We store it in c_FN_EXEC so an always-imm
  // fn can know which state was selected.
  XOR; SRMI DUP; @c_FN_EXEC $h2

  // also check for state.EXEC which overrides both
  .2 FTMI; @c_STATE $h2    @hasExec $c_CNL

  @PRE_MASK $c_IM  @stateClr $c_CNL // clear state.IMM
  LOR JZ; $jloc j_to
    @forceExec $c_JMP // IMM: forge execute
  $jset j_to
    @forceComp $c_JMP // not IMM: force compile
$dForget j_to


