// Bootstrap outselves outside of spore assembly and into spore proper.
// Requires: asm*.sa
//
// Main items we already have through device ports:
// - Token scanner (D_scan). Tokens are the same for spore asm as spore proper.
// - Local offset and location store (D_dict)
// - Assembler (D_comp)

// ******************
// * Compiler:

// 4 byte globals
$hAlign4
$loc rFN_PTR_MASK  .4 #FFFF_FFFF_FFFF,
$loc rI_IM       .4 @CNL  @IMWS ADD^,
$loc rI_CNL_IM   .4 @CNL  @IMWS ADD^,
$loc rI_CALL_IM  .4 @CALL @IMWS ADD^,
$loc rI_CLR      .4 #FFFF_0000, // instr clear

// State Globals
$loc STATE .2 #0,   // compiler state ` global-bits | fn-meta-bits `
$loc XSTATE .2 #0, // Execution state of a fn

// 16bit [global-bits | fn-meta-bits] Masks
#0001 =LCL_MASK // 1=has local stack
#0002 =PRE_MASK // 1=is prefix
#0004 =TNT_MASK // 1=is insTaNT
#0008 =ALI_MASK // 1=always instant ($ may alter behavior)

#0100 =EXEC_MASK // 1=everything is always instant.
#0200 =QUIT_MASK // 1=quit compLoop.

.4
$loc c_stateClr // {mask}
  NOT; FTMI AND; @STATE $h2
  SRMI RET; @STATE $h2
$loc c_stateSet // {mask}
  FTMI AND; @STATE $h2
  SRMI RET; @STATE $h2

$loc c_toMeta   IMWS SHR RET; #18 $h2 // shift to make just 8bit meta
$loc c_maskPre   IMWS AND RET; @PRE_MASK $h2
$loc c_maskIns // masks for ALI (always instant) and TNT
  @ALI_MASK $c_IM;
  IMWS OR; @TNT_MASK $h2
  AND RET;
$loc c_maskLcl   IMWS AND RET; @LCL_MASK $h2

$loc c_maskExec  IMWS AND RET; @EXEC_MASK $h2
$loc c_maskQuit  IMWS AND RET; @QUIT_MASK $h2

// Used by ALI (always instant) functions to know whether they've
// been asked to be "super" instant. Supper instant happens
// when `$` flips ALI's TNT bit or compiler state is EXEC
$loc c_stateSuperIns
  @STATE $c_FTMI2   @c_maskExec $c_CNL
  @XSTATE $c_FTMI2  @c_maskIns $c_CNL
  AND RET;


// Force execute a metaFn
$loc c_forceExec // {metaFn}
  .4 DUP;  @c_toMeta $c_CNL  @c_maskLcl $c_CNL // get meta
  SWP;  .4 FTMI AND; @rFN_PTR_MASK $h2 SWP; // get masked fn ptr
  JZ; $jloc j_call  .4 CALL; RET;
  $jset j_call      .4 CNL; RET;
$dForget j_call

$loc c_compMaskInstr // {maskInstr:4}
  @getSz $c_CNL  SWP; // cache sz {sz maskInstr}
  .4 IMWS DVS; @D_instr $h2 // use mask on instr
  .4 IMWS DVL; @D_instr $h2 // get instr
  @h2 $c_CNL // compile instr to heap

  // Clear current instr but with cached size
  .4 FTMI ADD; @rI_CLR $h2
  IMWS DVS RET; @D_instr $h2

// Force compile a metaFn to a value.
$loc c_forceComp // {metaFn}
  // TODO: make sure token is in same module.

  // Check if Fn is LCL or not
  .4 DUP;  @c_toMeta $c_CNL  @c_maskLcl $c_CNL
  JZ; $jloc j_cnl
    @rI_CALL_IM $c_FTMI4 // (has locals) fetch CALL mask+instr
    IMWS JMP; $jloc j_end
  $jset j_cnl
    .4 FTMI; @rI_CNL_IM $h2 // fetch CNL mask+instr
  $jset j_end
  @c_compMaskInstr $c_CNL  // mask and compile them mask+instr
  @h2 $c_JMP // Compile the fn ptr.
$dForget j_cnl

// Core Spore compiler function. Compiles the metaFn passed to it as a spore
// function, checking for PRE, TNT, ALI and LCL bits appropriately.
$loc c_compMetaFn // {metaFn} compile the meta fn
  // Check the meta for PRE. XOR with preBit to toggle
  .4 DUP;  @c_toMeta $c_CNL  @c_maskPre $c_CNL
  @STATE $c_FTMI2     @c_maskPre $c_CNL
  @PRE_MASK $c_IM     @c_stateClr $c_CNL // clear state.PRE

  XOR JZ; $jloc j_to // Checking for PRE.
    // Pre: simply compile next token.
    // Note: this is a forward call (c_comp not yet defined)
    IMWS CNL; $jloc j_c_comp
  $jset j_to

  // Check the meta for TNT or EXEC mode
  .4 DUP;  @c_toMeta $c_CNL   @c_maskIns $c_CNL
  @STATE $c_FTMI2             @c_maskIns $c_CNL
  // xor to toggle. We store it in XSTATE so an ALI fn can selected state.
  XOR; SRMI DUP; @XSTATE $h2

  // also check for state.EXEC which overrides both
  @STATE $c_FTMI2             @c_maskExec $c_CNL

  @PRE_MASK $c_IM  @c_stateClr $c_CNL // clear state.TNT
  LOR JZ; $jloc j_to
    @c_forceExec $c_JMP // instant: forge execute
  $jset j_to
    @c_forceComp $c_JMP // not instant: force compile
$jset j_c_comp    // update location of j_c_comp = c_comp (here)
$dForget j_to     // forget j_to and j_c_comp

$loc c_comp
  // Load dict ref and check it
  .4 IMWS DVL; @D_scan $h2
  // TODO: check if token is "#"

  .4 IMWS DVL; @D_rdict $h2 // {rValue}
  // Make sure token exists
  .4 DUP;  @E_DictDNE $c_IM  @assert $c_CNL
  FT; // fetch it {metaFn}
  @c_compMetaFn $c_JMP

$loc ASM_END // spore compilation loop. Calling will end ASM syntax.
  @QUIT_MASK $c_IM  @c_stateClr $c_CNL
  $loc j_loop
    @c_comp $c_CNL
    @STATE $c_FTMI2   @c_maskQuit $c_CNL
    JZ; $jloc j_quit
    IMWS JMP; @j_loop $h2
  $jset j_quit RET;
$dForget j_loop

// ******************
// * Core Syntax: define fns for the core syntax tokens.
$assertWsEmpty

$hAlign4
$loc c_rFN #0 .4, // dict ref of currently compiling fn.
$loc c_fnDictHeap #0 .4, // dict heap after defining current fn.

// usage: $floc <fn-name>
// Set location of spore fn. This is ultra-basic. The syntax is still assembly.
$loc c_floc
  #00FF $c_IM  @c_stateClr $c_CNL // clear toggle bits
  .2 SRMI ZERO; @XSTATE $h2       // clear XSTATE
  @loc $c_CNL // set location of next token
  .4 IMWS DVL; @D_rdict $h2 // get dictionary reference of current token
  SRMI; @c_rFN $h2 // store to c_rFN

  @c_rDictHeap $c_FTMI2
  .2 SRMI RET; @c_fnDictHeap $h2 // update fnDictHeap

$c_floc c_fnClean
  @assertWsEmpty $c_CNL
  @c_fnDictHeap $c_FTMI2 // fetch dict heap after current fn
  .2 SRMI RET; @c_rDictHeap $h2 // store to rDictHeap (forget keys after fn)

// {8bit mask} apply an 8-bit mask to the c_rFN (current fn ref)
$c_floc c_fnMask
  IMWS SHL; #18 $h2 // shift mask left by 0x18 (24)
  FTMI FT; @c_rFN $h2 // double fetch of rFN (get metaFn)
  SRMI OR RET; @c_rFN $h2 // bitwise-or mask and store.

$c_floc INSTANT          @TNT_MASK $c_IM  @c_fnMask $c_JMP // make INSTANT
                $INSTANT // make INSTANT an instant fn
$c_floc ALI     $INSTANT @ALI_MASK $c_IM  @c_fnMask $c_JMP // make ALI
$c_floc PRE     $INSTANT @PRE_MASK $c_IM  @c_fnMask $c_JMP // make PRE
$c_floc $       $INSTANT @TNT_MASK $c_IM  @c_stateSet $c_JMP  // toggle next INSTANT
$c_floc '       $INSTANT @PRE_MASK $c_IM  @c_stateSet $c_JMP  // toggle next PRE
$c_floc %%      $INSTANT @scan $c_CNL  .4 IMWS DVL RET; @D_comp $h2 // asm compile
$c_floc ASM_BEG          @QUIT_MASK $c_IM  @c_stateSet $c_JMP // begin assembly syntax

// Note: this actually isn't a comment. It's defining comments for spore.
$c_floc //      $INSTANT @scan $c_CNL  .4 IMWS DVL RET; @D_comp $h2 // asm compile

$c_floc #       $ALI // Immediate Value (hex constant)
  .4 IMWS DVL RET; @D_comp $h2 // assemble the '#' token with number.
  // If we are "super instant" simply return to keep number on stack.
  @c_stateSuperIns $c_CNL  NOT JZ; $jloc j_ret
  FTMI; @rI_IM $h2   @c_compMaskInstr $c_CNL // compile TNT instr
  @h2 $c_CNL // Compile the immediate value.
  $jset j_ret   RET
$c_fnClean   $c_dRef j_ret $tAssertNot // assert j_ret is deleted


$assertWsEmpty
