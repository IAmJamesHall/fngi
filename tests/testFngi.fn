$c_fngi

$tAssert(1)
$tAssertNot(0)
$tAssert(1 == 1)
SFN useEq ret(1 == 2);
$tAssertNot(useEq)

$tAssert(0x42 >= 0x30)
$tAssert(11 < 12)
$tAssert(lAnd(0x1, 0x8) == TRUE)
$tAssertEq(lAnd(0x1, 0x8), TRUE)
$tAssertNot(bAnd(0x1, 0x8))
$tAssertEq(bAnd(0xFF, 0xC), 0xC)
$tAssertEq(lOr(0x0, 0x8), TRUE)
$tAssertEq(bOr(0x0, 0x8), 0x8)
$tAssertEq(0c\t, 0x09)

$tAssertEq(FN_REF useEq, toRef(dictGet useEq))

$loc testFngiMsg  | Hello world from testFngi.fn!\n|
$_printz(testFngiMsg)

SFN daAnswer ret 0x42
SFN testXsw  ret xsw($lit(FN_REF daAnswer))
$tAssertEq(0x42, testXsw)


FN testSET PRE
  $SZ4 LOCAL a  END_LOCALS
  $assertWsEmpty
  4 _SET a
  SET a = inc(GET a)
  ret(GET a)
$tAssertEq(testSET, 5)

$(42 SZ1) GLOBAL glblAnswer
$tAssertEq(42, GET glblAnswer)

\ **********
\ ** Test Block Allocator
$tAssertEq(0xFF, BA_iNull)

$(0 SZ4) GLOBAL BA_fake;  $globalReserve(12 - 4)
$(0 SZ4) GLOBAL BA_fakeIndexes;

SFN BA_fakeInitForTest PRE \ {&indexes, &blocks, len) Initialize some fake data
  sr1(\len    , REF BA_fake + BA_lenOfs)
  sr4(\blocks , REF BA_fake + BA_blocksOfs)
  sr4(\indexes, REF BA_fake)
  ret sr1(0, REF BA_fake + BA_rootOfs)

$BA_fakeInitForTest(REF BA_fakeIndexes, 0x1000, 4)
$tAssertNot(BA_isPtrValid(0, REF BA_fake))      \ null block
$tAssertNot(BA_isPtrValid(0x500, REF BA_fake))
$tAssert   (BA_isPtrValid(0x1000, REF BA_fake)) \ 1st block
$tAssert   (BA_isPtrValid(0x2000, REF BA_fake)) \ 2nd block
$tAssert   (BA_isPtrValid(0x3000, REF BA_fake)) \ 3rd block
$tAssert   (BA_isPtrValid(0x4000, REF BA_fake)) \ 4th block
$tAssertNot(BA_isPtrValid(0x5000, REF BA_fake)) \ 5th block

$tAssertEq(BA_iNull, BA_ptrToI(0, REF BA_fake)) \ hard-coded
$tAssertEq(0,        BA_ptrToI(0x1000, REF BA_fake))
$tAssertEq(1,        BA_ptrToI(0x2000, REF BA_fake))
$tAssertEq(2,        BA_ptrToI(0x3000, REF BA_fake))

$tAssertEq(0,        BA_iToPtr(BA_iNull, REF BA_fake)) \ hard-coded
$tAssertEq(0x1000,   BA_iToPtr(0, REF BA_fake))
$tAssertEq(0x2000,   BA_iToPtr(1, REF BA_fake))
$tAssertEq(0x3000,   BA_iToPtr(2, REF BA_fake))
$tAssertEq(0x4000,   BA_iToPtr(3, REF BA_fake))
\ $tAssertEq(0x5000,   BA_iToPtr(4, REF BA_fake)) \ panics

$BA_init(REF BA_kernel) \ TODO: make this the fake block
FN testBASimple
  $SZ4 LOCAL blk
  $SZ1 LOCAL iBlk
  END_LOCALS
  tAssert(ft1(REF BA_kernel + BA_lenOfs))
  tAssertEq(0, ft1(REF BA_kernel + BA_rootOfs));
  tAssertEq(1, BA_iGet(0, REF BA_kernel));
  tAssertEq(2, BA_iGet(1, REF BA_kernel));

  SET iBlk = BA_iAlloc(REF BA_kernel);
  tAssertEq(0, GET iBlk)
  tAssertEq(1, ft1(REF BA_kernel + BA_rootOfs)); \ root changed
  SET blk = BA_iToPtr(GET iBlk, REF BA_kernel);
  tAssertEq(ft4(REF BA_kernel + BA_blocksOfs), GET blk)
  tAssertEq(GET blk,  BA_iToPtr(GET iBlk, REF BA_kernel));
  tAssertEq(ft4(REF BA_kernel + BA_blocksOfs), GET blk);
  tAssertEq(GET iBlk, BA_ptrToI(GET blk,  REF BA_kernel));
  BA_free(GET blk, REF BA_kernel)
  tAssertEq(0, ft1(REF BA_kernel + BA_rootOfs)); \ root changed
  tAssertEq(1, BA_iGet(0, REF BA_kernel));
  tAssertEq(2, BA_iGet(1, REF BA_kernel));
  ret;

$testBASimple

\ **********
\ ** Test SLL

$(NULL      SZ4) GLOBAL sll_c
$(REF sll_c SZ4) GLOBAL sll_b
$(REF sll_b SZ4) GLOBAL sll_a
$(REF sll_a SZ4) GLOBAL sll_root \ root->a->b->c

$tAssertEq(REF sll_a, SLL_pop(REF sll_root)) \ root->b->c
$tAssertEq(REF sll_b, SLL_pop(REF sll_root)) \ root->c
 $SLL_push(REF sll_a, REF sll_root)          \ root->a->c
$tAssertEq(REF sll_a, SLL_pop(REF sll_root)) \ root->c
$tAssertEq(REF sll_c, SLL_pop(REF sll_root)) \ root->NULL
$tAssertEq(NULL     , SLL_pop(REF sll_root))
$tAssertEq(NULL     , SLL_pop(REF sll_root))

\ **********
\ ** Test AA
$sort2(5 10) $tAssertEq(_, 10) $tAssertEq(_, 5)
$sort2(10 5) $tAssertEq(_, 10) $tAssertEq(_, 5)

$tAssert   (canBlocksMerge(16, 24, 3))
$tAssertNot(canBlocksMerge( 8, 16, 3))
$tAssertNot(canBlocksMerge( 8, 24, 3))
$tAssertNot(canBlocksMerge( 4, 12, 3))
$tAssertNot(canBlocksMerge(12, 20, 3))
$tAssertNot(canBlocksMerge(32, 64, 4))
$tAssert   (canBlocksMerge(64, 96, 5))
$tAssertNot(canBlocksMerge(64, 96, 4))

$tAssert(AA_isValidPo2(2))
$tAssert(AA_isValidPo2(3))
$tAssert(AA_isValidPo2(11))
$tAssert(AA_isValidPo2(12))
$tAssertNot(AA_isValidPo2(0))
$tAssertNot(AA_isValidPo2(1))
$tAssertNot(AA_isValidPo2(13))

$(0 SZ4) GLOBAL AA_fake;  $globalReserve(AA_size - 4)
$AA_init(REF BA_kernel, REF AA_fake)

\ Populate some fake data in freePo2 array
$sr4(2, REF AA_fake +  (2<<2))
$sr4(5, REF AA_fake +  (5<<2))
$sr4(10, REF AA_fake + (10<<2))

\ test AA_findPo2
$tAssertEq( 2, AA_findPo2(2, REF AA_fake))
$tAssertEq( 5, AA_findPo2(3, REF AA_fake))
$tAssertEq( 5, AA_findPo2(5, REF AA_fake))
$tAssertEq(10, AA_findPo2(6, REF AA_fake))
$tAssertEq(10, AA_findPo2(9, REF AA_fake))
$tAssertEq(10, AA_findPo2(10, REF AA_fake))
$tAssertEq(12, AA_findPo2(11, REF AA_fake))
$tAssertEq(12, AA_findPo2(12, REF AA_fake))

\ test AA_allocExactPo2 (except for po2=12)
$(BA_alloc(REF BA_kernel)
  SZA) GLOBAL AA_blk0;


\ Populate some "real fake" data.
SFN AA_initForTest PRE \ {&ba}
  AA_init(_, REF AA_fake)

  GET AA_blk0 + (1<<2); \ po2=2
  sr4(NULL, ovr)  sr4(_, REF AA_fake + (2<<2))

  GET AA_blk0 + (1<<5); \ po2=5
  sr4(NULL, ovr)  sr4(_, REF AA_fake + (5<<2))

  GET AA_blk0 + (1<<10); \ po2=10
  sr4(NULL, ovr)  sr4(_, REF AA_fake + (10<<2))
  ret;

$AA_initForTest(NULL);
$tAssertEq(GET AA_blk0 + (1<<2) , AA_allocExactPo2(2, REF AA_fake))
$tAssertEq(NULL                 , AA_allocExactPo2(3, REF AA_fake))
$tAssertEq(NULL                 , AA_allocExactPo2(4, REF AA_fake))
$tAssertEq(GET AA_blk0 + (1<<5) , AA_allocExactPo2(5, REF AA_fake))
$tAssertEq(NULL                 , AA_allocExactPo2(6, REF AA_fake))
$tAssertEq(GET AA_blk0 + (1<<10), AA_allocExactPo2(10, REF AA_fake))
$tAssertEq(NULL                 , AA_allocExactPo2(11, REF AA_fake))

\ All roots are now null
$tAssertEq(NULL, ft4(REF AA_fake + (2<<2)))
$tAssertEq(NULL, ft4(REF AA_fake + (3<<2)))
$tAssertEq(NULL, ft4(REF AA_fake + (5<<2)))
$tAssertEq(NULL, ft4(REF AA_fake + (10<<2)))

$AA_initForTest(NULL);
\ First let's do a freebie
$tAssertEq(GET AA_blk0 + (1<<2) ,          AA_allocPo2(2, REF AA_fake))

\ Now, we want to allocate 2^9, but that will require spliting 2^10
$tAssertEq(GET AA_blk0 + (1<<10),          AA_allocPo2(9, REF AA_fake))
$tAssertEq(GET AA_blk0 + (1<<10) + (1<<9), AA_allocPo2(9, REF AA_fake))
\ They should now both be exhausted
$tAssertEq(NULL, ft4(REF AA_fake + ( 9<<2)))
$tAssertEq(NULL, ft4(REF AA_fake + (10<<2)))

\ Let's do that again, but this time for 2^8
$AA_initForTest(NULL);
$tAssertEq(GET AA_blk0 + (1<<10),          AA_allocPo2(8, REF AA_fake))
$tAssertEq(GET AA_blk0 + (1<<10) + (1<<8), AA_allocPo2(8, REF AA_fake))
$tAssertEq(GET AA_blk0 + (1<<10) + (2<<8), AA_allocPo2(8, REF AA_fake))
$tAssertEq(GET AA_blk0 + (1<<10) + (3<<8), AA_allocPo2(8, REF AA_fake))
\ They are now all exhausted
$tAssertEq(NULL, ft4(REF AA_fake + ( 8<<2)))
$tAssertEq(NULL, ft4(REF AA_fake + ( 9<<2)))
$tAssertEq(NULL, ft4(REF AA_fake + (10<<2)))

\ Now we need to test that we can reserve an actual block
$BA_fakeInitForTest(REF BA_fakeIndexes, \blocks GET AA_blk0, 1)
$AA_initForTest(REF BA_fake)

\ TODO: write a test which reserves a ba block... it should just work :D

\ TODO: write and test FREEDOM

$BA_free(GET AA_blk0, REF BA_kernel)
